var documenterSearchIndex = {"docs":
[{"location":"#GeoData.jl","page":"GeoData.jl","title":"GeoData.jl","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GeoData","category":"page"},{"location":"#GeoData","page":"GeoData.jl","title":"GeoData","text":"GeoData\n\n(Image: ) (Image: ) (Image: Build Status) (Image: Codecov)\n\nGeoData.jl extends DimensionalData.jl so that spatial data can be indexed using named dimensions like Lat and Lon, which can also be used in most methods like mean and reduce where dimensions are required. Much of the behaviour is covered in the DimensionalData docs.\n\nGeoData.jl also defines common types and methods for accessing and working with spatial data, such as 2 or multidimensional raster arrays, multi-array \"stacks\", and \"series\" of stacks or arrays that behave similarly or identically across multiple file-types.\n\nIt provides general types GeoArray, GeoStack, and GeoSeries, R .grd files can be loaded natively using GRDarray and GRDstack. \n\nGDAL files can be loaded when ArchGDAL.jl (v0.5 or higher) is present, with GDALarray and GDALstack. NetCDF similarly can be loaded when NCDatasets.jl is loaded, with NCDarray and NCDstack.\n\nWhen HDF5.jl is loaded, files from the Soil Moisture Active Passive (SMAP) dataset can be loaded using SMAPstack or SMAPseries to load whole directories. This is both useful for users of SMAP, and a demonstration of the potential to build standardised interfaces  for custom spatial dataset formats like those used in SMAP.\n\nFiles can be written to disk in all formats using write.\n\nSome helper methods for common manipulations are included:\n\naggregate\ndisaggregate\nboolmask\nmissingmask\nreplace_missing\n\nThese will be expanded to include interpolation and other tools over time.\n\nThis is a work in progress and the API will break occasionally\n\nNotably GeoData will shift to relying on DiskArrays.jl for wrapping disk-based data sources when it fully supports GDAL and NetCDF. Currently this is handled internally. Broadcasting over disk base arrays like NCDarray will be incredibly slow, as chunk-based loading is not implemented. DiskArrays.jl will solve this, and other problems.\n\nThere are no also no guarantees on the accuracy of any of the included methods. If you are using this in critical applications, please do your own testing, or add additional tests to the GeoData.jl test suit to verify correctness.\n\nAlso note: writing directly to files with setindex! is not yet supported.  You must load to a GeoArray, make modifications and write a new file. \n\nGoals\n\nStandardisation: data from multiple sources has similar or identical syntax and behaviour.\nEasy, no-config plotting\nLazy loading: minimisation of memory requirements for large datasets\nAccuracy: Selectors should select exact regions, and handle points both  and intervals. \nMulti-layer, multi-file objects. GeoStack and GeoSeries facilitate simple operations over large datasets, with detail abstracted away from users and other packages.\n\nExamples\n\nWe'll load a file from disk, and do some manipulations and plotting.\n\nLoad GeoData, and NCDatasets, download file and load it to  an array. This netcdf file only has one layer, if it has more we  could use NCDstack instead.\n\nusing GeoData, NCDatasets\nurl = \"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\"\nfilename = download(url, \"tos_O1_2001-2002.nc\")\nA = NCDarray(filename)\n\nNow plot every third month in the first year, just using the regular index:\n\nusing Plots\nA[Ti(1:3:12)] |> plot\n\n(Image: Global ocean surface temperatures)\n\nNow plot Australia in the first month of 2001.\n\nA[Ti(Contains(DateTime360Day(2001, 01, 17))), \n  Lat(Between(0, -50)), \n  Lon(Between(100, 160))] |> plot\n\n(Image: Australia regional ocean surface temperature)\n\nNow get the mean over the timespan, then save it to disk, and plot it :\n\nusing Statistics\nmean_tos = mean(A; dims=Ti)\nwrite(\"mean.ncd, NCDarray, mean_tos))\nplot(mean_tos; color=:viridis) \n\n(Image: Mean temperatures)\n\nOr a plot transect of ocean surface temperature along the 20 degree latitude line:\n\nA[Lat(Contains(20)), Ti(1)] |> plot\n\n(Image: Temperatures at lattitude 20-21)\n\nWorks in progress\n\nStandardised handling and conversion of spatial metadata between data formats\nHandling complex projections: Affine transformation of dimensions to indices. AffineMaps will be stored as a wrapper dimension in dims.\nLoad and write NetCDF projection format\nIntegration with Vector/DataFrame spatial types and point/line/polygon data types. It should be possible to select polygons of data, and convert between linear datasets and array formats.\n\n\n\n\n\n","category":"module"},{"location":"#Dimensions","page":"GeoData.jl","title":"Dimensions","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Lat\nLon\nVert\nBand\nProjected\nConverted","category":"page"},{"location":"#GeoData.Lat","page":"GeoData.jl","title":"GeoData.Lat","text":"Lat <: YDim <: Dimension\nLat(val=:)\n\nLatitude Dimension.\n\nExample:\n\nvertdim = Lat(10:10:100)\n# Or\nval = A[Lat(1)]\n# Or\nmean(A; dims=Lat)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Lon","page":"GeoData.jl","title":"GeoData.Lon","text":"Lon <: XDim <: Dimension\nLon(val=:)\n\nLongitude Dimension.\n\nExample:\n\nlongdim = Lon(10:10:100)\n# Or\nval = A[Lon(1)]\n# Or\nmean(A; dims=Lon)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Vert","page":"GeoData.jl","title":"GeoData.Vert","text":"Vert <: ZDim <: Dimension\nVert(val=:)\n\nVertical Dimension.\n\nExample:\n\nvertdim = Vert(10:10:100)\n# Or\nval = A[Vert(1)]\n# Or\nmean(A; dims=Vert)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Band","page":"GeoData.jl","title":"GeoData.Band","text":"Band <: Dimension\nBand(val=:)\n\nBand Dimension for multi-band rasters.\n\nExample:\n\nbanddim = Band(10:10:100)\n# Or\nval = A[Band(1)]\n# Or\nmean(A; dims=Band)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Projected","page":"GeoData.jl","title":"GeoData.Projected","text":"Projected(order::Order, span, sampling, crs, usercrs)\nProjected(; order=Ordered(), span=UnknownSpan(), sampling=Points(), crs, usercrs=nothing)\n\nAn AbstractSampled mode with projections attached.\n\nFields and behaviours are identical to Sampled  with the addition of crs and usercrs fields.\n\nIf both crs and usercrs fields contain CRS data (in a GeoFormat wrapper  from GeoFormatTypes.jl) the selector inputs and plot axes will be converted  from and to the specified usercrs projection automatically. A common use case would be to pass usercrs=EPSG(4326) to the constructor when loading eg. a GDALarray:\n\nGDALarray(filename; usercrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf usercrs is not supplied (ie. usercrs=nothing), the base index will be  shown on plots, and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Converted","page":"GeoData.jl","title":"GeoData.Converted","text":"Converted(order::Order, span, sampling, crs, dimcrs)\nConverted(; order=Ordered(), span=UnknownSpan(), sampling=Points(), crs, dimcrs)\n\nAn AbstractSampled mode with projections, where the dimension  has already been converted to another projection as a vector, usually EPSG(4326).\n\nFields and behaviours are identical to Sampled with the addition of crs and dimcrs fields.\n\nThe dimension will be indexed as for Sampled, but to save in another format the underlying projection will be used.\n\nGDALarray(filename; usercrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf usercrs is not supplied (ie. usercrs=nothing), the base index will be  shown on plots, and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#Array","page":"GeoData.jl","title":"Array","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"AbstractGeoArray\nMemGeoArray\nDiskGeoArray\nGeoArray\nGDALarray\nGrdArray\nNCDarray","category":"page"},{"location":"#GeoData.AbstractGeoArray","page":"GeoData.jl","title":"GeoData.AbstractGeoArray","text":"AbstractGeoArray wraps an array (or location of an array) and metadata about its contents. It may be memory (GeoArray) or disk-backed (NCDarray, GDAlarray, GrdArray).\n\nAbstractGeoArrays inherit from AbstractDimensionalArray  from DimensionalData.jl. They can be indexed as regular Julia arrays or with  DimensionalData.jl Dimensions. They will plot as a heatmap in  Plots.jl with correct coordinates and labels, even after slicing with  getindex or view. getindex on a AbstractGeoArray will always return  a memory-backed GeoArray.\n\nIn addition to DimensionalArray behaviour,  these have metadata and missingval fields\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoArray","page":"GeoData.jl","title":"GeoData.MemGeoArray","text":"Abstract supertype for all memory-backed GeoArrays where the data is an array.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoArray","page":"GeoData.jl","title":"GeoData.DiskGeoArray","text":"Abstract supertype for all disk-backed GeoArrays. For these the data is lazyily loaded from disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoArray","page":"GeoData.jl","title":"GeoData.GeoArray","text":"GeoArray(A::AbstractArray{T,N}, dims::Tuple;\n         refdims=(), name=\"\", metadata=nothing, missingval=missing)\nGeoArray(A::AbstractGeoArray; [data=data(A), dims=dims(A), refdims=refdims(A),\n         name=name(A), metadata=metadata(A), missingval=missingval(A)]) =\n\nA generic, memory-backed spatial array type. All AbstractGeoArray are converted to GeoArray when indexed or otherwise transformed.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALarray","page":"GeoData.jl","title":"GeoData.GDALarray","text":"GDALarray(filename; usercrs=nothing, name=\"\", refdims=())\n\nLoad a file lazily with gdal. GDALarray will be converted to GeoArray after indexing or other manipulations. GeoArray(GDAlarray(filename)) will do this immediately.\n\nIf usercrs like EPSG(4326) is passed to the constructor, selectors like Between will use its projection, converting automatically to the underlying projection from GDAL. Plots will also display the axes using this projection.\n\nUntil DiskArrays.jl is used for this package, avoid broadcasting over GDALarray, convert to GeoArray first.\n\nArguments\n\nfilename: String pointing to a grd file. Extension is optional.\n\nKeyword arguments\n\nname: Name for the array.\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nusercrs: CRS format used in Between, At etc and Plotting. Can be any CRS GeoFormat form GeoFormatTypes.jl, such as WellKnownText loading the array.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDarray","page":"GeoData.jl","title":"GeoData.NCDarray","text":"NCDarray(filename::AbstractString; name=nothing, refdims=(),\n         dims=nothing, metadata=nothing, crs=EPSG(4326), dimcrs=EPSG(4326))\n\nCreate an array from a path to a netcdf file. The first non-dimension layer of the file will be used as the array.\n\nThis is an incomplete implementation of the NetCDF standard. It will currently only handle simple files in lattitude/longitude format, or projected formats if you manually specify crs and dimcrs. How this is done may also change in future, including detecting and converting the native NetCDF  projection format.\n\nArguments\n\nfilename: String pointing to a netcdf file.\n\nKeyword arguments\n\nname: Name for the array. Will use array key if not supplied.\nrefdims: Add dimension position array was sliced from. Mostly used programatically. loading the array. Can save on disk load time for large files.\ncrs: defaults to lat/lon EPSG(4326). If the underlying data is in a different  projection it will need to be set to allow write to a different file format.\ndimcrs: defaults to EPSG(4326), as it matches crs. However, the underlying data may be  projected, with the index still in lat/lon or something else. In this case specify a  projection using any projection type from GeoFormatTypes.jl.\n\n\n\n\n\n","category":"type"},{"location":"#Stack","page":"GeoData.jl","title":"Stack","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"AbstractGeoStack\nMemGeoStack\nGeoStack\nDiskGeoStack\nDiskStack\nGDALstack\nGrdStack\nNCDstack\nSMAPstack","category":"page"},{"location":"#GeoData.AbstractGeoStack","page":"GeoData.jl","title":"GeoData.AbstractGeoStack","text":"Stack objects hold multiple raster array that share spatial metadata and bounds.\n\nThese are NamedTuple-like structures that may either contain NamedTuple of AbstractGeoArray, string paths that will load AbstractGeoArray, or a single path that points to as a file structured as a multi-layered stack, like NetCDF.\n\nThe primary purpose of  is that use and syntax is identical for all cases, abstracting away data source and simplifying access code. getindex on any AbstractGeoStack may return a memory backed standard GeoArray, or a disk base AbstractGeoArray. geoarray[:somelayer] |> plot plots the layers array, while geoarray[:somelayer, Lon(1:100), Band(2)] |> plot will plot the subsetted array directly from disk, without loading the whole array.\n\ngetindex or view on a GeoStack returns another stack with the method applied to all the arrays in the stack.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoStack","page":"GeoData.jl","title":"GeoData.MemGeoStack","text":"An AbstractGeoStack stored in memory.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoStack","page":"GeoData.jl","title":"GeoData.GeoStack","text":"Concrete MemGeoStack implementation. Holds concrete GeoArray layers in memory.\n\ndata: A NamedTuple of GeoArray.\nwindow: A Tuple of Dimensions/Selectors/Indices that will be applied to the contained           arrays when they are accessed.\nrefdims: reference dimensions from earlier subsetting.\nmetadata: Any metadata object.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoStack","page":"GeoData.jl","title":"GeoData.DiskGeoStack","text":"AbstractGeoStacks stored on disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskStack","page":"GeoData.jl","title":"GeoData.DiskStack","text":"DiskStack(filename::NamedTuple; window=())\n\nLoad a stack of files lazily from disk.\n\nArguments\n\nfilename: a NamedTuple of String filenames.\n\nKeyword arguments\n\nwindow: can be a tuple of Dimensions, selectors or regular indices.\nchildtype: the type of the child data. eg. GDALarray.\nkwargs: keyword arguments to pass to the child constructor\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALstack","page":"GeoData.jl","title":"GeoData.GDALstack","text":"GDALstack(filenames; kwargs...)\n\nConvenience method to create a DiskStack  of GDALarray from filenames.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.NCDstack","page":"GeoData.jl","title":"GeoData.NCDstack","text":"NCDstack(filenames; refdims=(), window=(), metadata=nothing)\n\nA lazy DiskGeoStack that loads multiple single-layer netcdf  files or a single multi-layer file, using NCDatasets.jl.\n\nArguments\n\nfilename: Tuple or Vector of String paths to netcdf files,  or a single String path to a netcdf file.\n\nKeyword arguments\n\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nwindow: can be a tuple of Dimensions, selectors or regular indices.\nmetadata: Add additional metadata as a Dict.\nkeys: Keys for the layer in each file when filename is a Vector.\nchildkwargs: A NamedTuple of keyword arguments to pass to the child object constructor.\n\nExamples\n\nstack = NCDstack(filename; window=(Lat(Between(20, 40),))\nstack[:soil_temperature]\n# Or\nmultifile_stack = NCDstack([path1, path2, path3, path4])\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPstack","page":"GeoData.jl","title":"GeoData.SMAPstack","text":"SMAPstack(filename::String; window=())\n\nAbstractGeoStack for SMAP datasets.\n\nThe simplicity of the format means dims and metadata are the same for all stack layers, so we store them as stack fields. SMAPstack should also serve as an example of defining a custom source for HDF5 backed geospatial data.\n\nKeyword arguments\n\nwindow: Like view but lazy, for disk based data. Can be a tuple of Dimensions, selectors or regular indices. These will be applied when the data is loaded or indexed into.\n\n\n\n\n\n","category":"type"},{"location":"#Series","page":"GeoData.jl","title":"Series","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"AbstractGeoSeries\nGeoSeries\nSMAPseries","category":"page"},{"location":"#GeoData.AbstractGeoSeries","page":"GeoData.jl","title":"GeoData.AbstractGeoSeries","text":"AbstractGeoSeries are a high-level DimensionalArray that hold stacks, arrays,  or the paths they can be loaded from. GeoSeries are indexed with dimensions as with a AbstractGeoArray. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation. As much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.\n\nThis allows syntax like:\n\nseries[Time(Near(DateTime(2001, 1))][:temp][Lat(Between(70, 150)), Lon(Between(-20,20))] |> plot`\n\nGeoSeries is the only concrete implementation. It includes a chiltype field  indicating the constructor used then loading stacks or arrays of any type from disk, and holds a kwargs NamedTuple that will be splatted into to the keyword arguments of the childtype constructor. This gives control over the construction of lazy-loaded  files.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoSeries","page":"GeoData.jl","title":"GeoData.GeoSeries","text":"GeoSeries(data::Array{T}, dims; refdims=(), childtype=DD.basetypeof(T), \n          childkwargs=()) where T<:Union{<:AbstractGeoStack,<:AbstractGeoArray}\nGeoSeries(data, dims; refdims=(), childtype, childkwargs)\n\nConcrete implementation of AbstractGeoSeries. Series hold paths to array or stack files, along some dimension(s).\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPseries","page":"GeoData.jl","title":"GeoData.SMAPseries","text":"SMAPseries(dir::AbstractString; kwargs...) =\n    SMAPseries(joinpath.(dir, filter_ext(dir, \".h5\")); kwargs...)\nSMAPseries(filepaths::Vector{<:AbstractString}, dims=nothing; kwargs...) = begin\n\nSeries loader for SMAP folders (files in the time dimension). Returns a GeoSeries.\n\npath can be a String path to a directory of SMAP files, or a vector of String paths for specific files. kwargs are passed to the constructor for GeoSeries.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata","page":"GeoData.jl","title":"Metadata","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Metadata\nDimMetadata\nArrayMetadata\nStackMetadata\nGrdDimMetadata\nGrdArrayMetadata\nGDALdimMetadata\nGDALarrayMetadata\nNCDdimMetadata\nNCDarrayMetadata\nNCDstackMetadata\nSMAPdimMetadata\nSMAParrayMetadata\nSMAPstackMetadata","category":"page"},{"location":"#GeoData.Metadata","page":"GeoData.jl","title":"GeoData.Metadata","text":"Abstract type for all metadata wrappers.\n\nThese allow tracking the contents and origin of metadata.  This can facilitate conversion between metadata types (for saving  a file to a differenet format) or simply saving data back to the  same file type with identical metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DimMetadata","page":"GeoData.jl","title":"GeoData.DimMetadata","text":"Metadata wrappers to be attached to Dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.ArrayMetadata","page":"GeoData.jl","title":"GeoData.ArrayMetadata","text":"Metadata wrappers to be attached to AbstractGeoArrays.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.StackMetadata","page":"GeoData.jl","title":"GeoData.StackMetadata","text":"Metadata wrappers to be attached to AbstractGeoStack.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALdimMetadata","page":"GeoData.jl","title":"GeoData.GDALdimMetadata","text":"GDALmetadata(val::Dict)\n\nMetadata wrapper for GDALarray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALarrayMetadata","page":"GeoData.jl","title":"GeoData.GDALarrayMetadata","text":"GDALarrayMetadata(val::Dict)\n\nMetadata wrapper for GDALarray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDdimMetadata","page":"GeoData.jl","title":"GeoData.NCDdimMetadata","text":"NCDdimMetadata(val::Dict)\n\nMetadata wrapper for NCDarray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDarrayMetadata","page":"GeoData.jl","title":"GeoData.NCDarrayMetadata","text":"NCDarrayMetadata(val::Dict)\n\nMetadata wrapper for NCDarray metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDstackMetadata","page":"GeoData.jl","title":"GeoData.NCDstackMetadata","text":"NCDstackMetadata(val::Dict)\n\nMetadata wrapper for NCDarray metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPdimMetadata","page":"GeoData.jl","title":"GeoData.SMAPdimMetadata","text":"SMAPdimMetadata(val)\n\nDimMetadata wrapper for SMAParray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAParrayMetadata","page":"GeoData.jl","title":"GeoData.SMAParrayMetadata","text":"SMAParrayMetadata(val)\n\nArrayMetadata wrapper for SMAParray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPstackMetadata","page":"GeoData.jl","title":"GeoData.SMAPstackMetadata","text":"SMAPdimMetadata(val)\n\nStackMetadata wrapper for SMAPstack.\n\n\n\n\n\n","category":"type"},{"location":"#Helper-methods","page":"GeoData.jl","title":"Helper methods","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"See DimensionalData.jl docs for the majority of types and methods that can be used in GeoData.jl.  GeoData.jl is a direct extension of DimensionalData.jl.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"These methods are specific to GeoData.jl:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"write\ncat\ncopy!\nreplace_missing\nboolmask\nmissingmask\nconvertmode\nreproject\naggregate\naggregate!\ndisaggregate\ndisaggregate!\nGeoData.alloc_ag\nGeoData.alloc_disag","category":"page"},{"location":"#Base.write","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, T::Type{<:AbstractGeoArray}, s::AbstractGeoStack)\n\nSave all layers of an AbstractGeoStack to separate files, using the backend determined by T.\n\nExample\n\nwrite(filename, GDALarray, A)\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GRDarray}, s::AbstractGeoArray)\n\nWrite a GRDarray to a .grd file, with a .gri header file. The extension of filename will be ignored.\n\nCurrently the metadata field is lost on write.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GDALarray}, A::AbstractGeoArray;\n           driver=\"GTiff\", compress=\"DEFLATE\", tiled=true)\n\nWrite a GDALarray to file, .tiff by default, but other GDAL drivers also work.\n\nGDAL flags driver, compress and tiled can be passed in as keyword arguments.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDarray}, s::AbstractGeoArray)\n\nWrite an NCDarray to a netcdf file using NCDatasets.jl\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDstack}, s::AbstractGeoStack)\n\nWrite an NCDstack to a single netcdf file, using NCDatasets.jl.\n\nCurrently Dimension metadata is not handled, and array metadata from other array types is ignored.\n\n\n\n\n\n","category":"function"},{"location":"#Base.cat","page":"GeoData.jl","title":"Base.cat","text":"Base.cat(stacks::AbstractGeoStack...; [keys=keys(stacks[1])], dims)\n\nConcatenate all or a subset of layers for all passed in stacks.\n\nExample\n\ncat(stacks...; keys=(:sea_surface_temp, :humidity), dims)\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy!","page":"GeoData.jl","title":"Base.copy!","text":"Base.copy!(dst::AbstractGeoStack, src::AbstractGeoStack, [keys=keys(dst)])\n\nCopy all or a subset of layers from one stack to another.\n\nExample\n\ncopy!(dst::AbstractGeoStack, src::AbstractGeoStack, keys=(:sea_surface_temp, :humidity))\n\n\n\n\n\nBase.copy!(dst::AbstractArray, src::DiskGeoStack, key::Key)\n\nCopy the stack layer key to dst, which can be any AbstractArray.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.replace_missing","page":"GeoData.jl","title":"GeoData.replace_missing","text":"replace_missing(a::AbstractGeoArray, newmissing)\n\nReplace missing values in the array with a new missing value, also updating the missingval field.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.boolmask","page":"GeoData.jl","title":"GeoData.boolmask","text":"boolmask(A::AbstractArray, [missingval])\n\nCreate a mask array of Bool values, from any AbstractArray. For AbstractGeoArray  the default missingval is missingval(A), for all other AbstractArrays  it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a  GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.missingmask","page":"GeoData.jl","title":"GeoData.missingmask","text":"missingmask(A::AbstractArray, [missingval])\n\nCreate a mask array of missing or true values, from any AbstractArray.  For AbstractGeoArray the default missingval is missingval(A),  for all other AbstractArrays it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a  GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.convertmode","page":"GeoData.jl","title":"GeoData.convertmode","text":"convertmode(dstmode::Type{<:IndexMode}, x)\n\nConvert the dimension mode between Projected and Converted. Other dimension modes pass through unchanged.\n\nThis is used to e.g. save a netcdf file to GeoTiff.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.reproject","page":"GeoData.jl","title":"GeoData.reproject","text":"reproject uses ArchGDAL.reproject, but implemented for a reprojecting  a single dimension at a time.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, object, scale)\n\nAggregate array, or all arrays in a stack or series, by some scale.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nobject: Object to aggregate, like AbstractGeoSeries, AbstractStack,  AbstractGeoArray, Dimension\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate!","page":"GeoData.jl","title":"GeoData.aggregate!","text":"aggregate!(method, dst::AbstractDimensionalArray, src::AbstractDimensionalArray, scale)\n\nAggregate array src to array dst by scale, using method.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.disaggregate","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, object, scale)\n\nDisaggregate array, or all arrays in a stack or series, by some scale.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nobject: Object to aggregate, like AbstractGeoSeries, AbstractStack,  AbstractGeoArray, Dimension\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.disaggregate!","page":"GeoData.jl","title":"GeoData.disaggregate!","text":"disaggregate!(method, dst::AbstractDimensionalArray, src::AbstractDimensionalArray, scale)\n\nDisaggregate array src to array dst by some scale, using method.\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.alloc_ag","page":"GeoData.jl","title":"GeoData.alloc_ag","text":"alloc_ag(method, A::AbstractDimensionalArray, scale)\n\nAllocate an array of the correct size to aggregate A by scale\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.alloc_disag","page":"GeoData.jl","title":"GeoData.alloc_disag","text":"alloc_ag(method, A::AbstractDimensionalArray, scale)\n\nAllocate an array of the correct size to disaggregate A by scale\n\n\n\n\n\n","category":"function"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Field access:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"missingval\ncrs\nusercrs\ndimcrs\nuserbounds\nuserval\nGeoData.filename","category":"page"},{"location":"#GeoData.missingval","page":"GeoData.jl","title":"GeoData.missingval","text":"missingval(x)\n\nReturns the value representing missing data in the dataset\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.crs","page":"GeoData.jl","title":"GeoData.crs","text":"crs(x)\n\nGet the crs projection of a dim or for the Lat/Lon dims of an array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.usercrs","page":"GeoData.jl","title":"GeoData.usercrs","text":"usercrs(x)\n\nGet the user facing crs projection of a Projected mode  dim or for the Lat/Lon dims of an array.\n\nThis is used to convert Selector values form the user defined  projection to the underlying projection, and to show plot axes in the user projection.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.dimcrs","page":"GeoData.jl","title":"GeoData.dimcrs","text":"dimcrs(x)\n\nGet the index crs projection of a Converted mode dim or  for the Lat/Lon dims of an array.\n\nThis is used for NetCDF where the underlying projection of  the data may not be what is contained in the vector index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.userbounds","page":"GeoData.jl","title":"GeoData.userbounds","text":"userbounds(x)\n\nGet the bounds converted to the usercrs value.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.userval","page":"GeoData.jl","title":"GeoData.userval","text":"userval(x)\n\nGet the index value of a dimension converted to the usercrs value.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.filename","page":"GeoData.jl","title":"GeoData.filename","text":"filename(s::DiskGeoStack)\n\nReturn the filename field of a DiskGeoStack. This may be a Vector of String, or a String.\n\n\n\n\n\nfilename(s::DiskGeoStack, key)\n\nReturn the filename field of a DiskGeoStack for a given key.\n\nThis will always be a single string. However, in some cases all keys may have the same filename.\n\n\n\n\n\n","category":"function"}]
}
