<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GeoData.jl · GeoData.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GeoData.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>GeoData.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>GeoData.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GeoData.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rafaqz/GeoData.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GeoData.jl-1"><a class="docs-heading-anchor" href="#GeoData.jl-1">GeoData.jl</a><a class="docs-heading-anchor-permalink" href="#GeoData.jl-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoData" href="#GeoData.GeoData"><code>GeoData.GeoData</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>GeoData</strong></p><p><a href="https://rafaqz.github.io/GeoData.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://rafaqz.github.io/GeoData.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://travis-ci.org/rafaqz/GeoData.jl"><img src="https://travis-ci.org/rafaqz/GeoData.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/rafaqz/GeoData.jl"><img src="https://codecov.io/gh/rafaqz/GeoData.jl/branch/master/graph/badge.svg" alt="Codecov"/></a></p><p>GeoData.jl defines common types and methods for accessing and working with spatial data in Julia, such as 2 or multidimensional raster arrays. It provides general types <code>GeoArray</code>, <code>GeoStack</code>, and <code>GeoSeries</code>, and source specific types for loading GDAL, NetCDF and other file types,  available when packages like ArchGDAL.jl or NCDatasets.jl are loaded.</p><p>GeoData.jl is useful both as a scripting tool, and as a library of  standardised data manipulation for use in other geospatial data and modelling packages.</p><p>GeoData.jl extends <a href="https://github.com/rafaqz/DimensionalData.jl">DimensionalData.jl</a> so that data can be indexed using named dimensions, which can also be used in most methods like <code>mean</code> and <code>reduce</code> where dimensions are required. Most behaviour is covered in the <a href="https://rafaqz.github.io/DimensionalData.jl/stable/">DimensionalData docs</a>.</p><p><strong>Goals</strong></p><ul><li>Standardisation: data from multiple sources has similar or identical syntax and behaviour.</li><li>Easy, no-config plotting</li><li>Lazy loading: minimisation of memory requirements for large datasets</li><li>Accuracy: <code>Selector</code>s should select exact regions, and handle points both  and intervals. </li><li>Multi-layer, multi-file objects. <code>GeoStack</code> and <code>GeoSeries</code> facilitate simple operations over large datasets, with detail abstracted away from users and other packages.</li></ul><p><strong>Examples</strong></p><p>We&#39;ll load a file from disk, and do some manipulations and plotting.</p><p>Load GeoData, and NCDatasets, download file and load it to  an array. This netcdf file only has one layer, if it has more we  could use <code>NCDstack</code> instead.</p><pre><code class="language-julia">using GeoData, NCDatasets
filename = download(&quot;https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc&quot;, &quot;tos_O1_2001-2002.nc&quot;)
A = NCDarrar(filename)</code></pre><p>Now plot every third month in the first year, just using the regular index:</p><pre><code class="language-julia">using Plots
pyplot()
A[Ti(1:3:12)] |&gt; plot</code></pre><p>Now plot Australia in the first month of 2001.</p><pre><code class="language-julia">A[Ti(Contains(DateTime360Day(2001, 01, 17))), Lat(Between(0, -50)), Lon(Between(100, 160))] |&gt; plot</code></pre><p>Now plot a mean over the timespan, then save it to disk :</p><pre><code class="language-julia">mean(A; dims=Ti) |&gt; plot

write(&quot;mean.netcdf, NCDarray, mean(A; dims=Ti)))</code></pre><p>Or a transect of ocean surface temperature along the 20 degree latitude line:</p><pre><code class="language-julia">A[Lat(Contains(20)), Ti(1)] |&gt; plot</code></pre><p><strong>Works in progress</strong></p><ul><li>Standardised handling of metadata</li><li>Handling complex projections: Affine transformation of dimensions to indices. AffineMaps will be stored as a wrapper dimension in <code>dims</code>.</li><li>Integration with Vector/DataFrame spatial types and point/line/polygon data types. It should be possible to select polygons of data, and convert between linear datasets and array formats.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/GeoData.jl#L4-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.AbstractGeoArray" href="#GeoData.AbstractGeoArray"><code>GeoData.AbstractGeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AbstractGeoArray</code> wraps an array (or location of an array) and metadata about its contents. It may be memory (<code>GeoArray</code>) or disk-backed (<code>NCarray</code>, <code>GDAlarray</code>).</p><p><code>AbstractGeoArray</code>s inherit from <code>AbstractDimensionalArray</code> from DimensionalData. They can be indexed as regular Julia arrays or with DimensionalData.jl dimensions. They will plot as a heatmap in Plots.jl with correct coordinates and labels, even after slicing with <code>getindex</code> or <code>view</code>. <code>getindex</code> on a <code>AbstractGeoArray</code> will always return a standard <code>GeoArray</code>.</p><p>In addition to DimensionalArray behaviour, these have <code>metadata</code> and <code>missingval</code> fields</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.AbstractGeoSeries" href="#GeoData.AbstractGeoSeries"><code>GeoData.AbstractGeoSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractDimensionalArray</code> that holds or points to a series of stacks.</p><p><code>AbstractGeoSeries</code> are a high-level <code>DimensionalArray</code>s that hold stacks or arrays or the paths they can be loaded from. <code>GeoSeries</code> are indexed with dimensions as with a <code>AbstractGeoArray</code>. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation. As much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.</p><p>This allows</p><pre><code class="language-julia">series[Time(Near(DateTime(2001, 1))][:temp][Lat(Between(70, 150)), Lon(Between(-20,20))] |&gt; plot`</code></pre><p><code>GeoSeries</code> is the only concrete implementation, as it includes a field indicating its child constructor used if loading stacks or arrays of any type from disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/series.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.AbstractGeoStack" href="#GeoData.AbstractGeoStack"><code>GeoData.AbstractGeoStack</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stack objects hold multiple raster array that share spatial metadata and bounds.</p><p>These are NamedTuple-like structures that may either contain <code>NamedTuple</code> of <code>AbstractGeoArray</code>, string paths that will load <code>AbstractGeoArray</code>, or a single path that points to as a multi-layered stack of arrays.</p><p>The primary purpose of  is that use and syntax is identical for all cases, abstracting away data source and simplifying access code. <code>getindex</code> on any <code>AbstractGeoStack</code> may return a memory backed standard <code>GeoArray</code>, or a disk base AbstractGeoArray. <code>geoarray[:somelayer] |&gt; plot</code> plots the layers array, while <code>geoarray[:somelayer, Lon(1:100), Band(2)] |&gt; plot</code> will plot the subsetted array directly from disk, without loading the whole array.</p><p><code>getindex</code> on a GeoStack returns another stack with the method applied to all layers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.ArrayMetadata" href="#GeoData.ArrayMetadata"><code>GeoData.ArrayMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Metadata wrappers to be attached to <code>AbstractGeoArrays</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/metadata.jl#L27-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.DimMetadata" href="#GeoData.DimMetadata"><code>GeoData.DimMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Metadata wrappers to be attached to <code>Dimension</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/metadata.jl#L22-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GDALarray" href="#GeoData.GDALarray"><code>GeoData.GDALarray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GDALarray(filename; usercrs=nothing, name=&quot;&quot;, refdims=())</code></pre><p>Load a file lazily with gdal. GDALarray will be converted to GeoArray after indexing or other manipulations. <code>GeoArray(GDAlarray(filename))</code> will do this immediately.</p><p><code>EPSG</code> or <code>ProjString</code>. If <code>usercrs</code> is passed to the constructor, all selectors will use its projection, converting automatically to the underlying projection from GDAL.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: <code>String</code> pointing to a grd file. Extension is optional.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>name</code>: Name for the array.</li><li><code>refdims</code>: Add dimension position array was sliced from. Mostly used programatically.</li><li><code>usercrs</code>: can be any CRS <code>GeoFormat</code> form GeoFormatTypes.jl, such as <code>WellKnownText</code> loading the array. Can save on disk load time for large files.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/gdal.jl#L27-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GDALdimMetadata" href="#GeoData.GDALdimMetadata"><code>GeoData.GDALdimMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#GeoData.DimMetadata"><code>DimMetadata</code></a> wrapper for <code>GDALarray</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/gdal.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GDALmetadata" href="#GeoData.GDALmetadata"><code>GeoData.GDALmetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#GeoData.ArrayMetadata"><code>ArrayMetadata</code></a> wrapper for <code>GDALarray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/gdal.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoArray" href="#GeoData.GeoArray"><code>GeoData.GeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A generic, memory-backed spatial array type. All <a href="#GeoData.AbstractGeoArray"><code>AbstractGeoArray</code></a> are converted to GeoArray when indexed or otherwise transformed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L113-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoArray-Tuple{AbstractArray,Tuple}" href="#GeoData.GeoArray-Tuple{AbstractArray,Tuple}"><code>GeoData.GeoArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GeoArray(A::AbstractArray{T,N}, dims::Tuple;
         refdims=(), name=&quot;&quot;, metadata=nothing, missingval=missing)</code></pre><p>Construct a <a href="#GeoData.GeoArray"><code>GeoArray</code></a> from an <code>AbstractArray</code>, a <code>Tuple</code> of <code>Dimension</code> and keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L125-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoArray-Tuple{AbstractGeoArray}" href="#GeoData.GeoArray-Tuple{AbstractGeoArray}"><code>GeoData.GeoArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GeoArray(A::AbstractGeoArray; [data=data(A), dims=dims(A), refdims=refdims(A),
         name=name(A), metadata=metadata(A), missingval=missingval(A)]) =</code></pre><p>Construct a <a href="#GeoData.GeoArray"><code>GeoArray</code></a> from another <a href="#GeoData.AbstractGeoArray"><code>AbstractGeoArray</code></a>, and keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoSeries" href="#GeoData.GeoSeries"><code>GeoData.GeoSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Concrete implementation of <a href="#GeoData.AbstractGeoSeries"><code>AbstractGeoSeries</code></a>. Series hold paths to array or stack files, along some dimension(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/series.jl#L39-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoStack" href="#GeoData.GeoStack"><code>GeoData.GeoStack</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Concrete <code>MemGeoStack</code> implementation. Holds concrete <a href="#GeoData.GeoArray"><code>GeoArray</code></a> layers in memory.</p><ul><li><code>data</code>: A <code>NamedTuple</code> of <code>GeoArray</code>.</li><li><code>window</code>: A <code>Tuple</code> of Dimensions/Selectors/Indices that will be applied to the contained           arrays when they are accessed.</li><li><code>refdims</code>: reference dimensions from earlier subsetting.</li><li><code>metadata</code>: Any metadata object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L206-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoStack-Tuple{AbstractGeoStack}" href="#GeoData.GeoStack-Tuple{AbstractGeoStack}"><code>GeoData.GeoStack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GeoStack(s::AbstractGeoStack; [keys, data, refdims, window, metadata])</code></pre><p>Construct a <code>GeoStack</code> from another <code>GeoStack</code> and keyword arguments. <code>data</code> is a <code>NamedTuple</code> of <code>GeoArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L236-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoStack-Tuple{NamedTuple}" href="#GeoData.GeoStack-Tuple{NamedTuple}"><code>GeoData.GeoStack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GeoStack(data::NamedTuple; [window=()], [metadata=nothing], kwargs...) =</code></pre><p>Construct a <code>GeoStack</code> from a NamedTuple of <a href="#GeoData.GeoArray"><code>GeoArray</code></a> and keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoStack-Tuple{Vararg{AbstractGeoArray,N} where N}" href="#GeoData.GeoStack-Tuple{Vararg{AbstractGeoArray,N} where N}"><code>GeoData.GeoStack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GeoStack(data::Vararg{&lt;:AbstractGeoArray}; kwargs...)</code></pre><p>Convert <code>GeoArray</code>s to a <code>GeoStack</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GrdArray" href="#GeoData.GrdArray"><code>GeoData.GrdArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GrdArray(filename::String; refdims=(), name=nothing, usercrs=nothing)</code></pre><p>An <a href="#GeoData.AbstractGeoArray"><code>AbstractGeoArray</code></a> that loads .grd files lazily from disk.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: <code>String</code> pointing to a grd file. Extension is optional.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>name</code>: Name for the array. Will be loaded from <code>layername</code> if not supplied.</li><li><code>refdims</code>: Add dimension position array was sliced from. Mostly used programatically.</li><li><code>usercrs</code>: can be any CRS <code>GeoFormat</code> form GeoFormatTypes.jl, such as <code>WellKnownText</code> loading the array. Can save on disk load time for large files.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">array = GrdArray(&quot;folder/file.grd&quot;; usercrs=EPSG(4326))
# Select Australia using 4326 coords, whatever the crs is underneath.
array[Lat(Between(-10, -43), Lon(113, 153))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/grd.jl#L106-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GrdDimMetadata" href="#GeoData.GrdDimMetadata"><code>GeoData.GrdDimMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#GeoData.DimMetadata"><code>DimMetadata</code></a> wrapper for <code>GrdArray</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/grd.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GrdMetadata" href="#GeoData.GrdMetadata"><code>GeoData.GrdMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#GeoData.ArrayMetadata"><code>ArrayMetadata</code></a> wrapper for <code>GrdArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/grd.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.Metadata" href="#GeoData.Metadata"><code>GeoData.Metadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for dimension metadata wrappers, to be used  in dimension <code>metadata</code> fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/metadata.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.NCDarray" href="#GeoData.NCDarray"><code>GeoData.NCDarray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NCDarray(filename::AbstractString; name=&quot;&quot;, refdims=())</code></pre><p>Create an array from a path to a netcdf file. The first non-dimension layer of the file will be used as the array.</p><p>This is an incomplete implementation of the NetCDF standard. It will currently only handle simple files in lattitude/longitude format. Real projections are not yet handled. </p><p>If you need to use crs with NetCDF, make a fewture request in the issue queue.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: <code>String</code> pointing to a netcdf file.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>name</code>: Name for the array. Will use array key if not supplied.</li><li><code>refdims</code>: Add dimension position array was sliced from. Mostly used programatically. loading the array. Can save on disk load time for large files.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/ncdatasets.jl#L93-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.NCDstack-Tuple{AbstractString}" href="#GeoData.NCDstack-Tuple{AbstractString}"><code>GeoData.NCDstack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NCDstack(filename; refdims=(), window=(), metadata=nothing)</code></pre><p>A lazy GeoStack that loads netcdf files using NCDatasets.jl</p><p>Create a stack from the filename of a netcdf file.</p><p><strong>Arguments</strong></p><p>-<code>filename</code>: <code>String</code> path to a netcdf file.</p><p><strong>Keyword arguments</strong></p><ul><li><code>refdims</code>: Add dimension position array was sliced from. Mostly used programatically.</li><li><code>window</code>: can be a tuple of Dimensions, selectors or regular indices.</li><li><code>metadata</code>: Add additional metadata as a <code>Dict</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">stack = NCDstack(filename; window=(Lat(Between(20, 40),))
stack[:soil_temperature]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/ncdatasets.jl#L221-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.NCDstack-Tuple{Union{Tuple, Array{T,1} where T}}" href="#GeoData.NCDstack-Tuple{Union{Tuple, Array{T,1} where T}}"><code>GeoData.NCDstack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NCDstack(filenames; refdims=(), window=(), metadata=nothing)</code></pre><p>A lazy GeoStack that loads netcdf files using NCDatasets.jl</p><p>Create a stack from a list of filenames.</p><p><strong>Arguments</strong></p><p>-<code>filenames</code>: <code>Vector</code> of <code>String</code> paths to netcdf files.</p><p><strong>Keyword arguments</strong></p><ul><li><code>refdims</code>: Add dimension position array was sliced from. Mostly used programatically.</li><li><code>window</code>: can be a tuple of Dimensions, selectors or regular indices.</li><li><code>metadata</code>: Add additional metadata as a <code>Dict</code>.</li><li><code>keys</code>: Keys for the layer in each file in filenames. If these do not match a layer the first layer will be used. This is also the default.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">multifile_stack = NCDstack([path1, path2, path3, path4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/ncdatasets.jl#L191-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.Projected" href="#GeoData.Projected"><code>GeoData.Projected</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>AbstractSampled</code> (from DimensionalData.jl) with projections attached.</p><p>Fields and behaviours are identical to <code>Sampled</code> with the addition of <code>crs</code> and <code>usercrs</code> fields.</p><p>If both <code>crs</code> and <code>usercrs</code> fields contain crs data (in a GeoFormat wrapper  from GeoFormatTypes.jl) the selector inputs and plot axes will be converted  from and to the specified <code>usercrs</code> projection automatically. A common use case would be to pass <code>usercrs=EPSG(4326)</code> to the constructor when loading eg. a GDALarray:</p><pre><code class="language-julia">GDALarray(filename; usercrs=EPSG(4326))</code></pre><p>The underlying <code>crs</code> will be detected by GDAL.</p><p>If <code>usercrs</code> is not supplied (ie. <code>isa Nothing</code>), the base index will be shown on plots,  and selectors will need to use whatever format it is in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/mode.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAPdimMetadata" href="#GeoData.SMAPdimMetadata"><code>GeoData.SMAPdimMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#GeoData.DimMetadata"><code>DimMetadata</code></a> wrapper for <code>SMAPstack</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/smap.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAPmetadata" href="#GeoData.SMAPmetadata"><code>GeoData.SMAPmetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#GeoData.ArrayMetadata"><code>ArrayMetadata</code></a> wrapper for <code>GDALarray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/smap.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAPstack" href="#GeoData.SMAPstack"><code>GeoData.SMAPstack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SMAPstack(filename::String; window=())</code></pre><p><code>AbstractGeoStack</code> for <a href="https://smap.jpl.nasa.gov/">SMAP</a> datasets.</p><p>The simplicity of the format means dims and refdims are the same for all stack layers, so we store them as stack fields. <code>SMAPstack</code> should also serve as an example of defining a custom source for HDF5 backed geospatial data.</p><p><strong>Keyword arguments</strong></p><ul><li><code>window</code>: can be a tuple of Dimensions, selectors or regular indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/smap.jl#L26-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.data-Tuple{GeoData.DiskGeoArray}" href="#DimensionalData.data-Tuple{GeoData.DiskGeoArray}"><code>DimensionalData.data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">data(f, A::DiskGeoArray)</code></pre><p>Run method <code>f</code> on the data source object for A, as passed by the <code>withdata</code> method for the array. The only requirement of the object is that it has an <code>Array</code> method that returns the data as an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAPseries-Tuple{AbstractString}" href="#GeoData.SMAPseries-Tuple{AbstractString}"><code>GeoData.SMAPseries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SMAPseries(path; kwargs...)</code></pre><p>Series loader for SMAP folders (files in the time dimension). Returns a <a href="#GeoData.GeoSeries"><code>GeoSeries</code></a>.</p><p><code>path</code> can be a <code>String</code> path to a directory of SMAP files, or a vector of <code>String</code> paths for specific files. <code>kwargs</code> are passed to the constructor for <code>GeoSeries</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/smap.jl#L102-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate" href="#GeoData.aggregate"><code>GeoData.aggregate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aggregate(x, method, scale)</code></pre><p>Aggregate array, or all arrays in a stack or series, by some scale. This uses a <code>Array</code> aggregation function like <code>mean</code>, or a [<code>Locus</code>] type to specify a single position to sample from. Return values are <code>GeoArray</code>, <code>GeoStack</code> or <code>GeoSeries</code> depending on the type of <code>x</code>.</p><ul><li><code>method</code> is a function such as mean or sum that can combine the   value of multiple cells to generate the aggregated cell, or a loci   like <code>Start</code> or <code>Center()</code> that species where to sample from in the interval.</li><li><code>scale</code> is the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate" href="#GeoData.aggregate"><code>GeoData.aggregate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aggregate(method, stack::AbstractGeoStack, scale)</code></pre><p>Aggregate an AbstractGeoStack</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate!-Tuple{Locus,AbstractDimensionalArray,Any,Any}" href="#GeoData.aggregate!-Tuple{Locus,AbstractDimensionalArray,Any,Any}"><code>GeoData.aggregate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aggregate!(dst::AbstractDimensionalArray, src::AbstractDimensionalArray, method, scale)</code></pre><p>Aggregate array <code>src</code> to array <code>dst</code> by some scale. This uses an aggregation function like <code>mean</code> or a [<code>Locus</code>] type to specify a position to sample from.</p><ul><li><code>method</code> is a function such as mean or sum that can combine the   value of multiple cells to generate the aggregated cell, or a loci   like <code>Start</code> or <code>Center()</code> that species where to sample from in the interval.</li><li><code>scale</code> is the aggregation factor, which can be an integer, or a tuple of an <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L85-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate-Tuple{Any,AbstractDimensionalArray,Any}" href="#GeoData.aggregate-Tuple{Any,AbstractDimensionalArray,Any}"><code>GeoData.aggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aggregate(method, src::AbstractDimensionalArray, scale)</code></pre><p>Aggregate an AbstractDimensionalArray</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate-Tuple{Any,AbstractGeoSeries,Any,Vararg{Any,N} where N}" href="#GeoData.aggregate-Tuple{Any,AbstractGeoSeries,Any,Vararg{Any,N} where N}"><code>GeoData.aggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aggregate(method, series::AbstractGeoSeries, scale)</code></pre><p>Aggregate an AbstractGeoSeries</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate-Tuple{Any,Dimension,Any}" href="#GeoData.aggregate-Tuple{Any,Dimension,Any}"><code>GeoData.aggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aggregate(method, dim::Dimension, scale)</code></pre><p>Aggregate a Dimension</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate-Tuple{Any,IndexMode,Any}" href="#GeoData.aggregate-Tuple{Any,IndexMode,Any}"><code>GeoData.aggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aggregate(method, dim::IndexMode, scale)</code></pre><p>Aggregate an IndexMode</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate-Tuple{Any,Span,Any}" href="#GeoData.aggregate-Tuple{Any,Span,Any}"><code>GeoData.aggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aggregate(method, dim::Span, scale)</code></pre><p>Aggregate a Span</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.boolmask" href="#GeoData.boolmask"><code>GeoData.boolmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">boolmask(A::AbstractArray, [missingval])</code></pre><p>Create a mask array of <code>Bool</code> values, from any AbstractArray. For <code>AbstractGeoArray</code>  the default <code>missingval</code> is <code>missingval(A)</code>, for all other <code>AbstractArray</code>s  it is <code>missing</code>.</p><p>The array returned from calling <code>boolmask</code> on a <code>AbstractGeoArray</code> is a  <a href="#GeoData.GeoArray"><code>GeoArray</code></a> with the same size and fields as the oridingl array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/methods.jl#L16-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.crs" href="#GeoData.crs"><code>GeoData.crs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get the crs projection of a dim or for the <code>Lat</code>/<code>Lon</code> dims of an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/interface.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.crs-Tuple{AbstractGeoArray}" href="#GeoData.crs-Tuple{AbstractGeoArray}"><code>GeoData.crs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crs(A::AbstractGeoArray)</code></pre><p>Get the coordinate reference system of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L25-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.crs-Tuple{Dimension}" href="#GeoData.crs-Tuple{Dimension}"><code>GeoData.crs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crs(A::AbstractGeoArray)</code></pre><p>Get the coordinate reference system of a Dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L37-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.missingmask" href="#GeoData.missingmask"><code>GeoData.missingmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">missingmask(A::AbstractArray, [missingval])</code></pre><p>Create a mask array of <code>missing</code> or <code>true</code> values, from any AbstractArray.  For <code>AbstractGeoArray</code> the default <code>missingval</code> is <code>missingval(A)</code>,  for all other <code>AbstractArray</code>s it is <code>missing</code>.</p><p>The array returned from calling <code>boolmask</code> on a <code>AbstractGeoArray</code> is a  <a href="#GeoData.GeoArray"><code>GeoArray</code></a> with the same size and fields as the oridingl array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/methods.jl#L34-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.missingval" href="#GeoData.missingval"><code>GeoData.missingval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">missingval(x)</code></pre><p>Returns the value representing missing data in the dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/interface.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.replace_missing" href="#GeoData.replace_missing"><code>GeoData.replace_missing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">replace_missing(a::AbstractGeoArray, newmissing)</code></pre><p>Replace missing values in the array with a new missing value, also updating the <code>missingval</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/methods.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.usercrs" href="#GeoData.usercrs"><code>GeoData.usercrs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get the user facing crs projection of a dim or for the <code>Lat</code>/<code>Lon</code> dims of an array.</p><p>This is used to convert <code>Selector</code> values form the user defined projection  to the underlying projection, and to show plot axes in the user projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/interface.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.usercrs-Tuple{AbstractGeoArray}" href="#GeoData.usercrs-Tuple{AbstractGeoArray}"><code>GeoData.usercrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">usercrs(A::AbstractGeoArray)</code></pre><p>Get the coordinate reference system of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L42-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.usercrs-Tuple{Dimension}" href="#GeoData.usercrs-Tuple{Dimension}"><code>GeoData.usercrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">usercrs(A::AbstractGeoArray)</code></pre><p>Get the user input coordinate reference system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L54-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.DiskGeoArray" href="#GeoData.DiskGeoArray"><code>GeoData.DiskGeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for all disk-backed GeoArrays. For these the data is lazyily loaded from disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L74-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.DiskGeoStack" href="#GeoData.DiskGeoStack"><code>GeoData.DiskGeoStack</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for all disk backed <a href="#GeoData.AbstractGeoStack"><code>AbstractGeoStack</code></a>s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L120-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.DiskStack" href="#GeoData.DiskStack"><code>GeoData.DiskStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiskStack(filename::NamedTuple; window=())</code></pre><p>Load a stack of files lazily from disk.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: a NamedTuple of <code>String</code> filenames.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>window</code>: can be a tuple of Dimensions, selectors or regular indices.</li><li><code>childtype</code>: the type of the child data. eg. <code>GDALarray</code>.</li><li><code>kwargs</code>: keyword arguments to pass to the child constructor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L253-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.MemGeoArray" href="#GeoData.MemGeoArray"><code>GeoData.MemGeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for all memory-backed GeoArrays where the data is an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/array.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.MemGeoStack" href="#GeoData.MemGeoStack"><code>GeoData.MemGeoStack</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="#GeoData.AbstractGeoStack"><code>AbstractGeoStack</code></a> backed by memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L88-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cat-Tuple{Vararg{AbstractGeoStack,N} where N}" href="#Base.cat-Tuple{Vararg{AbstractGeoStack,N} where N}"><code>Base.cat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.cat(stacks::AbstractGeoStack...; [keys=keys(stacks[1])], dims)</code></pre><p>Concatenate all or a subset of layers for all passed in stacks.</p><p><strong>Example</strong></p><pre><code class="language-julia">cat(stacks...; keys=(:sea_surface_temp, :humidity), dims)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L310-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy!" href="#Base.copy!"><code>Base.copy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.copy!(dst::AbstractGeoStack, src::AbstractGeoStack, [keys=keys(dst)])</code></pre><p>Copy all or a subset of layers from one stack to another.</p><p><strong>Example</strong></p><pre><code class="language-julia">copy!(dst::AbstractGeoStack, src::AbstractGeoStack, keys=(:sea_surface_temp, :humidity))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L283-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy!-Tuple{AbstractArray,AbstractGeoStack,Any}" href="#Base.copy!-Tuple{AbstractArray,AbstractGeoStack,Any}"><code>Base.copy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.copy!(dst::AbstractArray, src::DiskGeoStack, key::Key)</code></pre><p>Copy the stack layer <code>key</code> to <code>dst</code>, which can be any <code>AbstractArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L302-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{AbstractString,Type{#s28} where #s28&lt;:NCDarray,AbstractGeoArray}" href="#Base.write-Tuple{AbstractString,Type{#s28} where #s28&lt;:NCDarray,AbstractGeoArray}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.write(filename::AbstractString, ::Type{NCDarray}, s::AbstractGeoArray)</code></pre><p>Write an NCDarray to a netcdf file using NCDatasets.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/ncdatasets.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{AbstractString,Type{#s28} where #s28&lt;:NCDstack,AbstractGeoStack}" href="#Base.write-Tuple{AbstractString,Type{#s28} where #s28&lt;:NCDstack,AbstractGeoStack}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.write(filename::AbstractString, ::Type{NCDstack}, s::AbstractGeoStack)</code></pre><p>Write an NCDstack to a single netcdf file, using NCDatasets.jl.</p><p>Currently <code>Dimension</code> metadata is not handled, and array metadata from other array types is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/ncdatasets.jl#L270-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{String,Type{#s16} where #s16&lt;:GrdArray,AbstractGeoArray}" href="#Base.write-Tuple{String,Type{#s16} where #s16&lt;:GrdArray,AbstractGeoArray}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.write(filename::AbstractString, ::Type{GrdArray}, s::AbstractGeoArray)</code></pre><p>Write a <a href="#GeoData.GrdArray"><code>GrdArray</code></a> to a .grd file, with a .gri header file. The extension of <code>filename</code> will be ignored.</p><p>Currently the <code>metadata</code> field is lost on <code>write</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/grd.jl#L161-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Union{Tuple{T}, Tuple{AbstractString,Type{#s3} where #s3&lt;:GDALarray,AbstractGeoArray{T,2,D,A} where A where D}} where T" href="#Base.write-Union{Tuple{T}, Tuple{AbstractString,Type{#s3} where #s3&lt;:GDALarray,AbstractGeoArray{T,2,D,A} where A where D}} where T"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.write(filename::AbstractString, ::Type{GDALarray}, A::AbstractGeoArray)</code></pre><p>Write a <a href="#GeoData.GDALarray"><code>GDALarray</code></a> to a .tiff file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/sources/gdal.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Union{Tuple{T}, Tuple{AbstractString,Type{T},AbstractGeoStack}} where T&lt;:AbstractGeoArray" href="#Base.write-Union{Tuple{T}, Tuple{AbstractString,Type{T},AbstractGeoStack}} where T&lt;:AbstractGeoArray"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.write(filename::AbstractString, T::Type{&lt;:AbstractGeoArray}, s::AbstractGeoStack)</code></pre><p>Save all layers of an <code>AbstractGeoStack</code> to separate files, using the backend determined by <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">write(filename, GDALarray, A)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L66-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.downsample-Tuple{Int64,Int64}" href="#GeoData.downsample-Tuple{Int64,Int64}"><code>GeoData.downsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">downsample(index::Int, scale::Int)</code></pre><p>Convert indicies from the original array to the aggregated array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.filename-Tuple{GeoData.DiskGeoStack{#s17} where #s17&lt;:NamedTuple,Union{AbstractString, Symbol}}" href="#GeoData.filename-Tuple{GeoData.DiskGeoStack{#s17} where #s17&lt;:NamedTuple,Union{AbstractString, Symbol}}"><code>GeoData.filename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filename(s::DiskGeoStack, key)</code></pre><p>Return the filename field of a <code>DiskGeoStack</code> for a given key.</p><p>This will always be a single string. However, in some cases all keys may have the same filename.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.filename-Tuple{GeoData.DiskGeoStack}" href="#GeoData.filename-Tuple{GeoData.DiskGeoStack}"><code>GeoData.filename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filename(s::DiskGeoStack)</code></pre><p>Return the filename field of a <code>DiskGeoStack</code>. This may be a <code>Vector</code> of <code>String</code>, or a <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.getsource" href="#GeoData.getsource"><code>GeoData.getsource</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getsource(s::AbstractGeoStack, [key])</code></pre><p>Get the lower lovel child object. This can be an <code>AbstractGeoArray</code> or a lower-level object with GeoData methods defined. Returning the low-level object can be better performance as we do not have to processes everything needed to build a full <code>AbstractGeoArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.kwargs-Tuple{AbstractGeoStack}" href="#GeoData.kwargs-Tuple{AbstractGeoStack}"><code>GeoData.kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kwargs(s::AbstractGeoStack)</code></pre><p>Returns the keyword arguments that will be passed to the child array constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/stack.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.safeapply" href="#GeoData.safeapply"><code>GeoData.safeapply</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">safeapply(f::Function, ::AbstractGeoStack, source)</code></pre><p>Wrapper method to apply a function to data object provided for by a data source.</p><p>This facilitates wrapping the custom file open/close requirements of specific  source libraries to safely deal with disk or api sourced datasets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/interface.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.upsample-Tuple{Int64,Int64}" href="#GeoData.upsample-Tuple{Int64,Int64}"><code>GeoData.upsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upsample(index::Int, scale::Int)</code></pre><p>Convert indicies from the aggregated array to the larger original array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/c007c2c6fd2d4fcd380bbaefc57e55ced49b050c/src/aggregate.jl#L136-L140">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 15 May 2020 10:34">Friday 15 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
