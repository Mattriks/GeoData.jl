var documenterSearchIndex = {"docs":
[{"location":"#GeoData.jl-1","page":"GeoData.jl","title":"GeoData.jl","text":"","category":"section"},{"location":"#","page":"GeoData.jl","title":"GeoData.jl","text":"Modules = [GeoData]\nOrder   = [:module, :type, :function, :macro]","category":"page"},{"location":"#GeoData.GeoData","page":"GeoData.jl","title":"GeoData.GeoData","text":"GeoData\n\n(Image: ) (Image: ) (Image: Build Status) (Image: Codecov)\n\nThe core goal of GeoData is to define common types and methods for accessing and working with spatial data in Julia, such as 2 or multidimensional raster arrays. It provides basic concrete data types, but may also be used as a library to add standardised data manipulation and plotting to other geospatial data packages.\n\nGeoData.jl extends DimensionalData.jl so that data can be indexed using named dimensions, which can also be used in most methods like mean and reduce where dimensions are required. Most behaviour is covered in the DimensionalData docs.\n\nDesign Goals\n\nStandardisation: data from multiple sources have similar or identical behaviour.\nEasy, no-config plotting\nLazy loading: minimisation of RAM requirements for large datasets\nAutomation of multi-file/multi-layer tasks with single line commands\nEcosystem integration: work as much as possible with existing packages\nUbiquitous DimensionalData.jl dims and selectors for indexing and dimension names, but hidden from custom implementations through the AbstractGeoX interfaces.\nAutomatic detection of dimension order, axis range and data orientation and order in format-specific implementations.\n\nWorks in progress\n\nStandardised handling of metadata\nHandling complex projections: Affine transformation of dimensions to indices. AffineMaps will be stored as a wrapper dimension in dims.\nIntegration with Vector/DataFrame spatial types and point/line/polygon data types. It should be possible to select polygons of data, and convert between linear datasets and array formats.\n\n\n\n\n\n","category":"module"},{"location":"#GeoData.AbstractGeoArray","page":"GeoData.jl","title":"GeoData.AbstractGeoArray","text":"AbstractGeoArray wraps an array (or location of an array) and metadata about its contents. It may be memory (GeoArray) or disk-backed (NCarray, GDAlarray).\n\nAbstractGeoArrays inherit from AbstractDimensionalArray from DimensionalData. They can be indexed as regular Julia arrays or with DimensionalData.jl dimensions. They will plot as a heatmap in Plots.jl with correct coordinates and labels, even after slicing with getindex or view. getindex on a AbstractGeoArray will always return a standard GeoArray.\n\nIn addition to DimensionalArray behaviour, these have metadata and missingval fields\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.AbstractGeoSeries","page":"GeoData.jl","title":"GeoData.AbstractGeoSeries","text":"An AbstractDimensionalArray that holds or points to a series of stacks.\n\nAbstractGeoSeries are a high-level DimensionalArrays that hold stacks or  arrays or the paths they can be loaded from. GeoSeries are indexed with dimensions  as with a AbstractGeoArray. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation. As much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.\n\nThis allows \n\nseries[Time(Near(DateTime(2001, 1))][:temp][Lat(Between(70, 150)), Lon(Between(-20,20))] |> plot`\n\nGeoSeries is the only concrete implementation, as it includes a field indicating its child type used if loading stacks or arrays of any type from disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.AbstractGeoStack","page":"GeoData.jl","title":"GeoData.AbstractGeoStack","text":"Stack objects hold multiple raster array that share spatial metadata and bounds.\n\nThese are NamedTuple-like structures that may either contain NamedTuple of AbstractGeoArray, string paths that will load AbstractGeoArray, or a single path that points to as a multi-layered stack of arrays. \n\nThe primary purpose of  is that use and syntax is identical for all cases, abstracting away data source and simplifying access code. getindex on any AbstractGeoStack may return a memory backed standard GeoArray, or a disk base AbstractGeoArray. geoarray[:somelayer] |> plot plots the layers array, while geoarray[:somelayer, Lon(1:100), Band(2)] |> plot will plot the subsetted array directly from disk, without loading the whole array. \n\ngetindex on a GeoStack returns another stack with the method applied to all layers.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.ArrayMetadata","page":"GeoData.jl","title":"GeoData.ArrayMetadata","text":"Metadata wrappers to be attached to AbstractGeoArrays.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DimMetadata","page":"GeoData.jl","title":"GeoData.DimMetadata","text":"Metadata wrappers to be attached to Dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALarray","page":"GeoData.jl","title":"GeoData.GDALarray","text":"GDALarray(filename; usercrs=nothing, name=\"\", window=())\n\nLoad a file lazily with gdal. GDALarray will be converted to GeoArray after indexing or other manipulations. GeoArray(GDAlarray(filename)) will do this immediately.\n\nEPSG or ProjString. If usercrs is passed to the constructor, all selectors will use its projection, converting automatically to the underlying projection from GDAL.\n\nArguments\n\nfilename: String pointing to a grd file. Extension is optional.\n\nKeyword arguments\n\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nusercrs: can be any CRS GeoFormat form GeoFormatTypes.jl, such as WellKnownText\nwindow: Tuple of Dimension, Selector or regular index to be applied when  loading the array. Can save on disk load time for large files.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALdimMetadata","page":"GeoData.jl","title":"GeoData.GDALdimMetadata","text":"DimMetadata wrapper for GDALarray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALmetadata","page":"GeoData.jl","title":"GeoData.GDALmetadata","text":"ArrayMetadata wrapper for GDALarray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALstack","page":"GeoData.jl","title":"GeoData.GDALstack","text":"GDALstack(filename::NamedTuple; refdims=(), window=())\n\nLoad a stack of files lazily with gdal.\n\nArguments\n\nfilename: a NamedTuple of String filenames.\n\nKeyword arguments\n\nwindow: can be a tuple of Dimensions, selectors or regular indices.\nmetadata: is a GDALmetadata object.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoArray","page":"GeoData.jl","title":"GeoData.GeoArray","text":"A generic, memory-backed spatial array type. All AbstractGeoArray are converted to GeoArray when indexed or otherwise transformed.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoArray-Tuple{GeoData.MemGeoArray}","page":"GeoData.jl","title":"GeoData.GeoArray","text":"GeoArray(A::AbstractGeoArray; [data=data(A), dims=dims(A), refdims=refdims(A),\n         name=name(A), metadata=metadata(A), missingval=missingval(A)]) =\n\nConstruct a GeoArray from another AbstractGeoArray, and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GeoArray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple}} where N where T","page":"GeoData.jl","title":"GeoData.GeoArray","text":"GeoArray(A::AbstractArray{T,N}, dims::Tuple;\n         refdims=(), name=\"\", metadata=nothing, missingval=missing)\n\nConstruct a GeoArray from an AbstractArray, a Tuple of Dimension and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GeoSeries","page":"GeoData.jl","title":"GeoData.GeoSeries","text":"Concrete implementation of AbstractGeoSeries. Series hold paths to array or stack files, along some dimension(s).\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoStack","page":"GeoData.jl","title":"GeoData.GeoStack","text":"Concrete MemGeoStack implementation. Holds concrete GeoArray layers in memory.\n\ndata: A NamedTuple of GeoArray.\nwindow: A Tuple of Dimensions/Selectors/Indices that will be applied to the contained           arrays when they are accessed.\nrefdims: reference dimensions from earlier subsetting.\nmetadata: Any metadata object.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoStack-Tuple{AbstractGeoStack}","page":"GeoData.jl","title":"GeoData.GeoStack","text":"GeoStack(s::AbstractGeoStack; [keys, data, refdims, window, metadata])\n\nConstruct a GeoStack from another GeoStack and keyword arguments. data is a NamedTuple of GeoArray.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GeoStack-Tuple{NamedTuple}","page":"GeoData.jl","title":"GeoData.GeoStack","text":"GeoStack(data::NamedTuple; [refdims=()], [window=()], [metadata=nothing]) =\n\nConstruct a GeoStack from a NamedTuple of GeoArray and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GeoStack-Tuple{Vararg{AbstractGeoArray,N} where N}","page":"GeoData.jl","title":"GeoData.GeoStack","text":"GeoStack(data::Vararg{<:AbstractGeoArray}; kwargs...)\n\nConvert GeoArrays arguments to a GeoStack.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GrdArray","page":"GeoData.jl","title":"GeoData.GrdArray","text":"GrdArray(filename::String; refdims=(), name=nothing, window=(), usercrs=nothing)\n\nAn AbstractGeoArray that loads .grd files lazily from disk.\n\nArguments\n\nfilename: String pointing to a grd file. Extension is optional.\n\nKeyword arguments\n\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nusercrs: can be any CRS GeoFormat form GeoFormatTypes.jl, such as WellKnownText\nwindow: Tuple of Dimension, Selector or regular index to be applied when  loading the array. Can save on disk load time for large files.\n\nExample\n\narray = GrdArray(\"folder/file.grd\"; usercrs=EPSG(4326))\n# Select Australia using 4326 coords, whatever the crs is underneath.\narray[Lat(Between(-10, -43), Lon(113, 153))\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GrdDimMetadata","page":"GeoData.jl","title":"GeoData.GrdDimMetadata","text":"DimMetadata wrapper for GrdArray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GrdMetadata","page":"GeoData.jl","title":"GeoData.GrdMetadata","text":"ArrayMetadata wrapper for GrdArray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Metadata","page":"GeoData.jl","title":"GeoData.Metadata","text":"Abstract type for dimension metadata wrappers, to be used  in dimension metadata fields.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDarray","page":"GeoData.jl","title":"GeoData.NCDarray","text":"NCDarray(filename::AbstractString; refdims=(), window=())\n\nCreate an array from a path to a netcdf file. The first non-dimension layer of the file will be used as the array.\n\nArguments\n\nfilename: String pointing to a netcdf file.\n\nKeyword arguments\n\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nwindow: Tuple of Dimension, Selector or regular index to be applied when  loading the array. Can save on disk load time for large files.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDstack","page":"GeoData.jl","title":"GeoData.NCDstack","text":"NCDstack(filename; refdims=(), window=(), metadata=nothing)\n\nA lazy GeoStack that loads netcdf files using NCDatasets.jl\n\nCreate a stack from the filename of a netcdf file. Passing a  vector of String will create a stack from multiple files.  The first non-dimension layer of each file will be used in the stack.\n\nArguments\n\n-filename: String or Vector of String pointing to netcdf file(s).\n\nKeyword arguments\n\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nwindow: can be a tuple of Dimensions, selectors or regular indices.\nmetadata: Add additional metadata as a Dict.\n\nExamples\n\nstack = NCDstack(filename; window=(Lat(Between(20, 40),))\nstack[:soil_temperature]\n\nmultifile_stack = NCDstack([path1, path2, path3, path4])\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.ProjectedIndex","page":"GeoData.jl","title":"GeoData.ProjectedIndex","text":"A AbstractSampled (from DimensionalData.jl) with projections attached.\n\nFields and behaviours are identical to Sampled with the addition of crs and usercrs fields.\n\nIf both crs and usercrs fields contain crs data (in a GeoFormat wrapper  from GeoFormatTypes.jl) the selector inputs and plot axes will be converted  from and to the specified usercrs projection automatically. A common use case would be to pass usercrs=EPSG(4326) to the constructor when loading eg. a GDALarray:\n\nGDALarray(filename; usercrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf usercrs is not supplied (ie. isa Nothing), the base index will be shown on plots,  and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPdimMetadata","page":"GeoData.jl","title":"GeoData.SMAPdimMetadata","text":"DimMetadata wrapper for SMAPstack dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPmetadata","page":"GeoData.jl","title":"GeoData.SMAPmetadata","text":"ArrayMetadata wrapper for GDALarray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPstack","page":"GeoData.jl","title":"GeoData.SMAPstack","text":"SMAPstack(filename::String; window=())\n\nAbstractGeoStack for SMAP datasets.\n\nThe simplicity of the format means dims and refdims are the same for all stack layers, so we store them as stack fields. SMAPstack should also serve as an example of defining  a custom source for HDF5 backed geospatial data.\n\nKeyword arguments\n\nwindow: can be a tuple of Dimensions, selectors or regular indices.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPseries-Tuple{AbstractString}","page":"GeoData.jl","title":"GeoData.SMAPseries","text":"SMAPseries(path; kwargs...)\n\nSeries loader for SMAP folders (files in the time dimension).  Returns a GeoSeries.\n\npath can be a String path to a directory of SMAP files,  or a vector of String paths for specific files. kwargs are passed to the constructor for GeoSeries.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(x, method, scale)\n\nAggregate array, or all arrays in a stack or series, by some scale. This uses a Array aggregation function like mean, or a [Locus] type to specify a single position to sample from. Return values are GeoArray, GeoStack or GeoSeries depending on the type of x.\n\nmethod is a function such as mean or sum that can combine the   value of multiple cells to generate the aggregated cell, or a loci   like Start or Center() that species where to sample from in the interval.\nscale is the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, stack::AbstractGeoStack, scale)\n\nAggregate an AbstractGeoStack\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate!-Tuple{Locus,AbstractDimensionalArray,Any,Any}","page":"GeoData.jl","title":"GeoData.aggregate!","text":"aggregate!(dst::AbstractDimensionalArray, src::AbstractDimensionalArray, method, scale)\n\nAggregate array src to array dst by some scale. This uses an aggregation function like mean or a [Locus] type to specify a position to sample from.\n\nmethod is a function such as mean or sum that can combine the   value of multiple cells to generate the aggregated cell, or a loci   like Start or Center() that species where to sample from in the interval.\nscale is the aggregation factor, which can be an integer, or a tuple of an Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate-Tuple{Any,AbstractDimensionalArray,Any}","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, src::AbstractDimensionalArray, scale)\n\nAggregate an AbstractDimensionalArray\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate-Tuple{Any,AbstractGeoSeries,Any,Vararg{Any,N} where N}","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, series::AbstractGeoSeries, scale)\n\nAggregate an AbstractGeoSeries\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.boolmask","page":"GeoData.jl","title":"GeoData.boolmask","text":"boolmask(A::AbstractArray, [missingval])\n\nCreate a mask array of Bool values, from any AbstractArray. For AbstractGeoArray  the default missingval is missingval(A), for all other AbstractArrays  it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a  GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.crs","page":"GeoData.jl","title":"GeoData.crs","text":"Get the crs projection of a dim or for the Lat/Lon dims of an array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.crs-Tuple{AbstractGeoArray}","page":"GeoData.jl","title":"GeoData.crs","text":"crs(A::AbstractGeoArray)\n\nGet the coordinate reference system of the array.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.crs-Tuple{Dimension}","page":"GeoData.jl","title":"GeoData.crs","text":"crs(A::AbstractGeoArray)\n\nGet the coordinate reference system of a Dimension.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.missingmask","page":"GeoData.jl","title":"GeoData.missingmask","text":"missingmask(A::AbstractArray, [missingval])\n\nCreate a mask array of missing or true values, from any AbstractArray.  For AbstractGeoArray the default missingval is missingval(A),  for all other AbstractArrays it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a  GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.missingval","page":"GeoData.jl","title":"GeoData.missingval","text":"missingval(x)\n\nReturns the value representing missing data in the dataset\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.replace_missing","page":"GeoData.jl","title":"GeoData.replace_missing","text":"replace_missing(a::AbstractGeoArray, newmissing)\n\nReplace missing values in the array with a new missing value, also updating the missingval field.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.usercrs","page":"GeoData.jl","title":"GeoData.usercrs","text":"Get the user facing crs projection of a dim or for the Lat/Lon dims of an array.\n\nThis is used to convert Selector values form the user defined projection  to the underlying projection, and to show plot axes in the user projection.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.usercrs-Tuple{AbstractGeoArray}","page":"GeoData.jl","title":"GeoData.usercrs","text":"usercrs(A::AbstractGeoArray)\n\nGet the coordinate reference system of the array.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.usercrs-Tuple{Dimension}","page":"GeoData.jl","title":"GeoData.usercrs","text":"usercrs(A::AbstractGeoArray)\n\nGet the user input coordinate reference system.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.DiskGeoArray","page":"GeoData.jl","title":"GeoData.DiskGeoArray","text":"Abstract supertype for all disk-backed GeoArrays. For these the data is lazyily loaded from disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoStack","page":"GeoData.jl","title":"GeoData.DiskGeoStack","text":"Abstract supertype for all disk backed AbstractGeoStacks\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoArray","page":"GeoData.jl","title":"GeoData.MemGeoArray","text":"Abstract supertype for all memory-backed GeoArrays where the data is an array.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoStack","page":"GeoData.jl","title":"GeoData.MemGeoStack","text":"AbstractGeoStack backed by memory.\n\n\n\n\n\n","category":"type"},{"location":"#Base.cat-Tuple{Vararg{AbstractGeoStack,N} where N}","page":"GeoData.jl","title":"Base.cat","text":"Base.cat(stacks::AbstractGeoStack...; [keys=keys(stacks[1])], dims)\n\nConcatenate all or a subset of layers for all passed in stacks.\n\nExample\n\ncat(stacks...; keys=(:sea_surface_temp, :humidity), dims)\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy!","page":"GeoData.jl","title":"Base.copy!","text":"Base.copy!(dst::AbstractGeoStack, src::AbstractGeoStack, [keys=keys(dst)])\n\nCopy all or a subset of layers from one stack to another.\n\nExample\n\ncopy!(dst::AbstractGeoStack, src::AbstractGeoStack, keys=(:sea_surface_temp, :humidity))\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy!-Tuple{AbstractArray,GDALstack,Union{AbstractString, Symbol}}","page":"GeoData.jl","title":"Base.copy!","text":"Base.copy!(dst::AbstractArray, src::GDALstack, key::Key)\n\nCopy the stack layer key to dst, which can be any AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{AbstractString,Type{NCDarray},AbstractGeoArray}","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, ::Type{NCDarray}, s::AbstractGeoArray)\n\nWrite an NCDarray to a netcdf file using NCDatasets.jl\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{AbstractString,Type{NCDstack},AbstractGeoStack}","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, ::Type{NCDstack}, s::AbstractGeoStack)\n\nWrite an NCDstack to a single netcdf file, using NCDatasets.jl.\n\nCurrently Dimension metadata is not handled, and array metadata from other array types is ignored.\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{String,Type{GrdArray},AbstractGeoArray}","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, ::Type{GrdArray}, s::AbstractGeoArray)\n\nWrite a GrdArray to a .grd file, with a .gri header file. The extension of  filename will be ignored. \n\nCurrently the metadata field is lost on write. \n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Union{Tuple{T}, Tuple{AbstractString,Type{T},AbstractGeoStack}} where T<:AbstractGeoArray","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, T::Type{<:AbstractGeoArray}, s::AbstractGeoStack)\n\nSave all layers of an AbstractGeoStack to separate files, using the backend determined by T.\n\nExample\n\nwrite(filename, GDALArray, stack)\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.downsample-Tuple{Int64,Int64}","page":"GeoData.jl","title":"GeoData.downsample","text":"downsample(index::Int, scale::Int)\n\nConvert indicies from the original array to the aggregated array.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.filename-Tuple{GeoData.DiskGeoStack{#s18} where #s18<:NamedTuple,Union{AbstractString, Symbol}}","page":"GeoData.jl","title":"GeoData.filename","text":"filename(s::DiskGeoStack, key)\n\nReturn the filename field of a DiskGeoStack for a given key.\n\nThis will always be a single string. However, in some cases  all keys may have the same filename.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.filename-Tuple{GeoData.DiskGeoStack}","page":"GeoData.jl","title":"GeoData.filename","text":"filename(s::DiskGeoStack)\n\nReturn the filename field of a DiskGeoStack. This may be a Vector of String, or a String.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.safeapply","page":"GeoData.jl","title":"GeoData.safeapply","text":"safeapply(f::Function, ::AbstractGeoStack, source)\n\nWrapper method to apply a function to data object provided for by a data source.\n\nThis facilitates wrapping the custom file open/close requirements of specific  source libraries to safely deal with disk or api sourced datasets.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.source","page":"GeoData.jl","title":"GeoData.source","text":"source(s::AbstractGeoStack, [key])\n\nThe data source of an AbstractGeoStack is an abstraction that can be either: a named tuple of filepaths to files containing single layers; a single filepath for a file containing layers with multiple keys; or a NamedTuple that contains multiple AbstractGeoArrays.\n\nIt allows the same methods to apply to many different file types and structures.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.upsample-Tuple{Int64,Int64}","page":"GeoData.jl","title":"GeoData.upsample","text":"upsample(index::Int, scale::Int)\n\nConvert indicies from the aggregated array to the larger original array.\n\n\n\n\n\n","category":"method"}]
}
