var documenterSearchIndex = {"docs":
[{"location":"#GeoData.jl","page":"GeoData.jl","title":"GeoData.jl","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Modules = [GeoData]\nOrder   = [:module, :type, :function, :macro]","category":"page"},{"location":"#GeoData.GeoData","page":"GeoData.jl","title":"GeoData.GeoData","text":"GeoData\n\n(Image: ) (Image: ) (Image: Build Status) (Image: Codecov)\n\nGeoData.jl defines common types and methods for accessing and working with spatial data in Julia, such as 2 or multidimensional raster arrays. It provides general types GeoArray, GeoStack, and GeoSeries, and source specific types for loading GDAL, NetCDF and other file types,  available when packages like ArchGDAL.jl or NCDatasets.jl are loaded.\n\nGeoData.jl is useful both as a scripting tool, and as a library of  standardised data manipulation for use in other geospatial data and modelling packages.\n\nGeoData.jl extends DimensionalData.jl so that data can be indexed using named dimensions, which can also be used in most methods like mean and reduce where dimensions are required. Most behaviour is covered in the DimensionalData docs.\n\nGoals\n\nStandardisation: data from multiple sources has similar or identical syntax and behaviour.\nEasy, no-config plotting\nLazy loading: minimisation of memory requirements for large datasets\nAccuracy: Selectors should select exact regions, and handle points both  and intervals. \nMulti-layer, multi-file objects. GeoStack and GeoSeries facilitate simple operations over large datasets, with detail abstracted away from users and other packages.\n\nExamples\n\nWe'll load a file from disk, and do some manipulations and plotting.\n\nLoad GeoData, and NCDatasets, download file and load it to  an array. This netcdf file only has one layer, if it has more we  could use NCDstack instead.\n\nusing GeoData, NCDatasets\nfilename = download(\"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\", \"tos_O1_2001-2002.nc\")\nA = NCDarray(filename)\n\nNow plot every third month in the first year, just using the regular index:\n\nusing Plots\npyplot()\nA[Ti(1:3:12)] |> plot\n\n(Image: Global ocean surface temperatures)\n\nNow plot Australia in the first month of 2001.\n\nA[Ti(Contains(DateTime360Day(2001, 01, 17))), Lat(Between(0, -50)), Lon(Between(100, 160))] |> plot\n\n(Image: Australia regional ocean surface temperature)\n\nNow get the mean over the timespan, then save it to disk, and plot :\n\nusing Statistics\nmean_tos = mean(A; dims=Ti)\nwrite(\"mean.ncd\", NCDarray, mean_tos)\nplot(mean_tos; color=:viridis) \n\n(Image: Temperatures at lattitude 20-21)\n\nOr a plot transect of ocean surface temperature along the 20 degree latitude line:\n\nA[Lat(Contains(20)), Ti(1)] |> plot\n\n(Image: Temperatures at lattitude 20-21)\n\nWorks in progress\n\nStandardised handling of metadata\nHandling complex projections: Affine transformation of dimensions to indices. AffineMaps will be stored as a wrapper dimension in dims.\nIntegration with Vector/DataFrame spatial types and point/line/polygon data types. It should be possible to select polygons of data, and convert between linear datasets and array formats.\n\n\n\n\n\n","category":"module"},{"location":"#GeoData.AbstractGeoArray","page":"GeoData.jl","title":"GeoData.AbstractGeoArray","text":"AbstractGeoArray wraps an array (or location of an array) and metadata about its contents. It may be memory (GeoArray) or disk-backed (NCarray, GDAlarray).\n\nAbstractGeoArrays inherit from AbstractDimensionalArray from DimensionalData. They can be indexed as regular Julia arrays or with DimensionalData.jl dimensions. They will plot as a heatmap in Plots.jl with correct coordinates and labels, even after slicing with getindex or view. getindex on a AbstractGeoArray will always return a standard GeoArray.\n\nIn addition to DimensionalArray behaviour, these have metadata and missingval fields\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.AbstractGeoSeries","page":"GeoData.jl","title":"GeoData.AbstractGeoSeries","text":"An AbstractDimensionalArray that holds or points to a series of stacks.\n\nAbstractGeoSeries are a high-level DimensionalArrays that hold stacks or arrays or the paths they can be loaded from. GeoSeries are indexed with dimensions as with a AbstractGeoArray. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation. As much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.\n\nThis allows\n\nseries[Time(Near(DateTime(2001, 1))][:temp][Lat(Between(70, 150)), Lon(Between(-20,20))] |> plot`\n\nGeoSeries is the only concrete implementation, as it includes a field indicating its child constructor used if loading stacks or arrays of any type from disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.AbstractGeoStack","page":"GeoData.jl","title":"GeoData.AbstractGeoStack","text":"Stack objects hold multiple raster array that share spatial metadata and bounds.\n\nThese are NamedTuple-like structures that may either contain NamedTuple of AbstractGeoArray, string paths that will load AbstractGeoArray, or a single path that points to as a multi-layered stack of arrays.\n\nThe primary purpose of  is that use and syntax is identical for all cases, abstracting away data source and simplifying access code. getindex on any AbstractGeoStack may return a memory backed standard GeoArray, or a disk base AbstractGeoArray. geoarray[:somelayer] |> plot plots the layers array, while geoarray[:somelayer, Lon(1:100), Band(2)] |> plot will plot the subsetted array directly from disk, without loading the whole array.\n\ngetindex on a GeoStack returns another stack with the method applied to all layers.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.ArrayMetadata","page":"GeoData.jl","title":"GeoData.ArrayMetadata","text":"Metadata wrappers to be attached to AbstractGeoArrays.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Converted","page":"GeoData.jl","title":"GeoData.Converted","text":"Converted(order::Order, span, sampling, crs, dimcrs)\nConverted(; order=Ordered(), span=UnknownSpan(), sampling=Points(), crs, dimcrs)\n\nAn AbstractSampled mode with projections, where the dimension has already been converted to another projection as a vector, usually EPSG(4326).\n\nFields and behaviours are identical to Sampled with the addition of crs and dimcrs fields.\n\nThe dimension will be indexed as for Sampled, but to save in another format the underlying projection will be used.\n\nGDALarray(filename; usercrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf usercrs is not supplied (ie. isa Nothing), the base index will be shown on plots,  and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DimMetadata","page":"GeoData.jl","title":"GeoData.DimMetadata","text":"Metadata wrappers to be attached to Dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoArray","page":"GeoData.jl","title":"GeoData.DiskGeoArray","text":"Abstract supertype for all disk-backed GeoArrays. For these the data is lazyily loaded from disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoStack","page":"GeoData.jl","title":"GeoData.DiskGeoStack","text":"Abstract supertype for all disk backed AbstractGeoStacks\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskStack","page":"GeoData.jl","title":"GeoData.DiskStack","text":"DiskStack(filename::NamedTuple; window=())\n\nLoad a stack of files lazily from disk.\n\nArguments\n\nfilename: a NamedTuple of String filenames.\n\nKeyword arguments\n\nwindow: can be a tuple of Dimensions, selectors or regular indices.\nchildtype: the type of the child data. eg. GDALarray.\nkwargs: keyword arguments to pass to the child constructor\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALarray","page":"GeoData.jl","title":"GeoData.GDALarray","text":"GDALarray(filename; usercrs=nothing, name=\"\", refdims=())\n\nLoad a file lazily with gdal. GDALarray will be converted to GeoArray after indexing or other manipulations. GeoArray(GDAlarray(filename)) will do this immediately.\n\nEPSG or ProjString. If usercrs is passed to the constructor, all selectors will use its projection, converting automatically to the underlying projection from GDAL.\n\nArguments\n\nfilename: String pointing to a grd file. Extension is optional.\n\nKeyword arguments\n\nname: Name for the array.\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nusercrs: can be any CRS GeoFormat form GeoFormatTypes.jl, such as WellKnownText loading the array. Can save on disk load time for large files.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALdimMetadata","page":"GeoData.jl","title":"GeoData.GDALdimMetadata","text":"DimMetadata wrapper for GDALarray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALmetadata","page":"GeoData.jl","title":"GeoData.GDALmetadata","text":"ArrayMetadata wrapper for GDALarray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoArray","page":"GeoData.jl","title":"GeoData.GeoArray","text":"A generic, memory-backed spatial array type. All AbstractGeoArray are converted to GeoArray when indexed or otherwise transformed.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoArray-Tuple{AbstractArray,Tuple}","page":"GeoData.jl","title":"GeoData.GeoArray","text":"GeoArray(A::AbstractArray{T,N}, dims::Tuple;\n         refdims=(), name=\"\", metadata=nothing, missingval=missing)\n\nConstruct a GeoArray from an AbstractArray, a Tuple of Dimension and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GeoArray-Tuple{AbstractGeoArray}","page":"GeoData.jl","title":"GeoData.GeoArray","text":"GeoArray(A::AbstractGeoArray; [data=data(A), dims=dims(A), refdims=refdims(A),\n         name=name(A), metadata=metadata(A), missingval=missingval(A)]) =\n\nConstruct a GeoArray from another AbstractGeoArray, and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GeoSeries","page":"GeoData.jl","title":"GeoData.GeoSeries","text":"Concrete implementation of AbstractGeoSeries. Series hold paths to array or stack files, along some dimension(s).\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoStack","page":"GeoData.jl","title":"GeoData.GeoStack","text":"Concrete MemGeoStack implementation. Holds concrete GeoArray layers in memory.\n\ndata: A NamedTuple of GeoArray.\nwindow: A Tuple of Dimensions/Selectors/Indices that will be applied to the contained           arrays when they are accessed.\nrefdims: reference dimensions from earlier subsetting.\nmetadata: Any metadata object.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoStack-Tuple{AbstractGeoStack}","page":"GeoData.jl","title":"GeoData.GeoStack","text":"GeoStack(s::AbstractGeoStack; [keys, data, refdims, window, metadata])\n\nConstruct a GeoStack from another GeoStack and keyword arguments. data is a NamedTuple of GeoArray.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GeoStack-Tuple{NamedTuple}","page":"GeoData.jl","title":"GeoData.GeoStack","text":"GeoStack(data::NamedTuple; [window=()], [metadata=nothing], kwargs...) =\n\nConstruct a GeoStack from a NamedTuple of GeoArray and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GeoStack-Tuple{Vararg{AbstractGeoArray,N} where N}","page":"GeoData.jl","title":"GeoData.GeoStack","text":"GeoStack(data::Vararg{<:AbstractGeoArray}; kwargs...)\n\nConvert GeoArrays to a GeoStack.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.GrdArray","page":"GeoData.jl","title":"GeoData.GrdArray","text":"GrdArray(filename::String; refdims=(), name=nothing, usercrs=nothing)\n\nAn AbstractGeoArray that loads .grd files lazily from disk.\n\nArguments\n\nfilename: String pointing to a grd file. Extension is optional.\n\nKeyword arguments\n\nname: Name for the array. Will be loaded from layername if not supplied.\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nusercrs: can be any CRS GeoFormat form GeoFormatTypes.jl, such as WellKnownText loading the array. Can save on disk load time for large files.\n\nExample\n\narray = GrdArray(\"folder/file.grd\"; usercrs=EPSG(4326))\n# Select Australia using 4326 coords, whatever the crs is underneath.\narray[Lat(Between(-10, -43), Lon(113, 153))\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GrdDimMetadata","page":"GeoData.jl","title":"GeoData.GrdDimMetadata","text":"DimMetadata wrapper for GrdArray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GrdMetadata","page":"GeoData.jl","title":"GeoData.GrdMetadata","text":"ArrayMetadata wrapper for GrdArray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.LatLon","page":"GeoData.jl","title":"GeoData.LatLon","text":"LatLon(order, span, sampling)\nLatLon(; order=Ordered(), span=UnknownSpan(), sampling=Points())\n\nAn AbstractSampled mode for standard latitude/longitude dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoArray","page":"GeoData.jl","title":"GeoData.MemGeoArray","text":"Abstract supertype for all memory-backed GeoArrays where the data is an array.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoStack","page":"GeoData.jl","title":"GeoData.MemGeoStack","text":"AbstractGeoStack backed by memory.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Metadata","page":"GeoData.jl","title":"GeoData.Metadata","text":"Abstract type for dimension metadata wrappers, to be used  in dimension metadata fields.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDarray","page":"GeoData.jl","title":"GeoData.NCDarray","text":"NCDarray(filename::AbstractString; name=\"\", refdims=())\n\nCreate an array from a path to a netcdf file. The first non-dimension layer of the file will be used as the array.\n\nThis is an incomplete implementation of the NetCDF standard. It will currently only handle simple files in lattitude/longitude format. Real projections are not yet handled.\n\nIf you need to use crs with NetCDF, make a fewture request in the issue queue.\n\nArguments\n\nfilename: String pointing to a netcdf file.\n\nKeyword arguments\n\nname: Name for the array. Will use array key if not supplied.\nrefdims: Add dimension position array was sliced from. Mostly used programatically. loading the array. Can save on disk load time for large files.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDstack-Tuple{AbstractString}","page":"GeoData.jl","title":"GeoData.NCDstack","text":"NCDstack(filename; refdims=(), window=(), metadata=nothing)\n\nA lazy GeoStack that loads netcdf files using NCDatasets.jl\n\nCreate a stack from the filename of a netcdf file.\n\nArguments\n\n-filename: String path to a netcdf file.\n\nKeyword arguments\n\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nwindow: can be a tuple of Dimensions, selectors or regular indices.\nmetadata: Add additional metadata as a Dict.\n\nExamples\n\nstack = NCDstack(filename; window=(Lat(Between(20, 40),))\nstack[:soil_temperature]\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.NCDstack-Tuple{Union{Tuple, Array{T,1} where T}}","page":"GeoData.jl","title":"GeoData.NCDstack","text":"NCDstack(filenames; refdims=(), window=(), metadata=nothing)\n\nA lazy GeoStack that loads netcdf files using NCDatasets.jl\n\nCreate a stack from a list of filenames.\n\nArguments\n\n-filenames: Vector of String paths to netcdf files.\n\nKeyword arguments\n\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nwindow: can be a tuple of Dimensions, selectors or regular indices.\nmetadata: Add additional metadata as a Dict.\nkeys: Keys for the layer in each file in filenames. If these do not match a layer the first layer will be used. This is also the default.\n\nExamples\n\nmultifile_stack = NCDstack([path1, path2, path3, path4])\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.Projected","page":"GeoData.jl","title":"GeoData.Projected","text":"Projected(order::Order, span, sampling, crs, usercrs)\nProjected(; order=Ordered(), span=UnknownSpan(), sampling=Points(), crs, usercrs=nothing)\n\nAn AbstractSampled mode with projections attached.\n\nFields and behaviours are identical to Sampled with the addition of crs and usercrs fields.\n\nIf both crs and usercrs fields contain crs data (in a GeoFormat wrapper  from GeoFormatTypes.jl) the selector inputs and plot axes will be converted  from and to the specified usercrs projection automatically. A common use case would be to pass usercrs=EPSG(4326) to the constructor when loading eg. a GDALarray:\n\nGDALarray(filename; usercrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf usercrs is not supplied (ie. isa Nothing), the base index will be shown on plots,  and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPdimMetadata","page":"GeoData.jl","title":"GeoData.SMAPdimMetadata","text":"DimMetadata wrapper for SMAPstack dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPmetadata","page":"GeoData.jl","title":"GeoData.SMAPmetadata","text":"ArrayMetadata wrapper for GDALarray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPstack","page":"GeoData.jl","title":"GeoData.SMAPstack","text":"SMAPstack(filename::String; window=())\n\nAbstractGeoStack for SMAP datasets.\n\nThe simplicity of the format means dims and refdims are the same for all stack layers, so we store them as stack fields. SMAPstack should also serve as an example of defining a custom source for HDF5 backed geospatial data.\n\nKeyword arguments\n\nwindow: can be a tuple of Dimensions, selectors or regular indices.\n\n\n\n\n\n","category":"type"},{"location":"#Base.cat-Tuple{Vararg{AbstractGeoStack,N} where N}","page":"GeoData.jl","title":"Base.cat","text":"Base.cat(stacks::AbstractGeoStack...; [keys=keys(stacks[1])], dims)\n\nConcatenate all or a subset of layers for all passed in stacks.\n\nExample\n\ncat(stacks...; keys=(:sea_surface_temp, :humidity), dims)\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy!","page":"GeoData.jl","title":"Base.copy!","text":"Base.copy!(dst::AbstractGeoStack, src::AbstractGeoStack, [keys=keys(dst)])\n\nCopy all or a subset of layers from one stack to another.\n\nExample\n\ncopy!(dst::AbstractGeoStack, src::AbstractGeoStack, keys=(:sea_surface_temp, :humidity))\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy!-Tuple{AbstractArray,AbstractGeoStack,Any}","page":"GeoData.jl","title":"Base.copy!","text":"Base.copy!(dst::AbstractArray, src::DiskGeoStack, key::Key)\n\nCopy the stack layer key to dst, which can be any AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{AbstractString,Type,AbstractGeoArray}","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, ::Type{NCDarray}, s::AbstractGeoArray)\n\nWrite an NCDarray to a netcdf file using NCDatasets.jl\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{AbstractString,Type{#s39} where #s39<:NCDstack,AbstractGeoStack}","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, ::Type{NCDstack}, s::AbstractGeoStack)\n\nWrite an NCDstack to a single netcdf file, using NCDatasets.jl.\n\nCurrently Dimension metadata is not handled, and array metadata from other array types is ignored.\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{String,Type{#s15} where #s15<:GrdArray,AbstractGeoArray}","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, ::Type{GrdArray}, s::AbstractGeoArray)\n\nWrite a GrdArray to a .grd file, with a .gri header file. The extension of filename will be ignored.\n\nCurrently the metadata field is lost on write.\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Union{Tuple{T}, Tuple{AbstractString,Type{#s3} where #s3<:GDALarray,AbstractGeoArray{T,2,D,A} where A where D}} where T","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, ::Type{GDALarray}, A::AbstractGeoArray)\n\nWrite a GDALarray to a .tiff file.\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Union{Tuple{T}, Tuple{AbstractString,Type{T},AbstractGeoStack}} where T<:AbstractGeoArray","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, T::Type{<:AbstractGeoArray}, s::AbstractGeoStack)\n\nSave all layers of an AbstractGeoStack to separate files, using the backend determined by T.\n\nExample\n\nwrite(filename, GDALarray, A)\n\n\n\n\n\n","category":"method"},{"location":"#DimensionalData.data-Tuple{GeoData.DiskGeoArray}","page":"GeoData.jl","title":"DimensionalData.data","text":"data(f, A::DiskGeoArray)\n\nRun method f on the data source object for A, as passed by the withdata method for the array. The only requirement of the object is that it has an Array method that returns the data as an array.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.SMAPseries-Tuple{AbstractString}","page":"GeoData.jl","title":"GeoData.SMAPseries","text":"SMAPseries(path; kwargs...)\n\nSeries loader for SMAP folders (files in the time dimension). Returns a GeoSeries.\n\npath can be a String path to a directory of SMAP files, or a vector of String paths for specific files. kwargs are passed to the constructor for GeoSeries.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(x, method, scale)\n\nAggregate array, or all arrays in a stack or series, by some scale. This uses a Array aggregation function like mean, or a [Locus] type to specify a single position to sample from. Return values are GeoArray, GeoStack or GeoSeries depending on the type of x.\n\nmethod is a function such as mean or sum that can combine the   value of multiple cells to generate the aggregated cell, or a loci   like Start or Center() that species where to sample from in the interval.\nscale is the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate!-Tuple{Locus,AbstractDimensionalArray,Any,Any}","page":"GeoData.jl","title":"GeoData.aggregate!","text":"aggregate!(dst::AbstractDimensionalArray, src::AbstractDimensionalArray, method, scale)\n\nAggregate array src to array dst by some scale. This uses an aggregation function like mean or a [Locus] type to specify a position to sample from.\n\nmethod is a function such as mean or sum that can combine the   value of multiple cells to generate the aggregated cell, or a loci   like Start or Center() that species where to sample from in the interval.\nscale is the aggregation factor, which can be an integer, or a tuple of an Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate-Tuple{Any,AbstractDimensionalArray,Any}","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, src::AbstractDimensionalArray, scale)\n\nAggregate an AbstractDimensionalArray\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate-Tuple{Any,AbstractGeoSeries,Any,Vararg{Any,N} where N}","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, series::AbstractGeoSeries, scale)\n\nAggregate an AbstractGeoSeries\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate-Tuple{Any,AbstractGeoStack,Any}","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, stack::AbstractGeoStack, scale)\n\nAggregate an AbstractGeoStack\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate-Tuple{Any,Dimension,Any}","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, dim::Dimension, scale)\n\nAggregate a Dimension\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate-Tuple{Any,IndexMode,Any}","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, dim::IndexMode, scale)\n\nAggregate an IndexMode\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.aggregate-Tuple{Any,Span,Any}","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, dim::Span, scale)\n\nAggregate a Span\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.boolmask","page":"GeoData.jl","title":"GeoData.boolmask","text":"boolmask(A::AbstractArray, [missingval])\n\nCreate a mask array of Bool values, from any AbstractArray. For AbstractGeoArray  the default missingval is missingval(A), for all other AbstractArrays  it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a  GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.crs","page":"GeoData.jl","title":"GeoData.crs","text":"Get the crs projection of a dim or for the Lat/Lon dims of an array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.crs-Tuple{AbstractGeoArray}","page":"GeoData.jl","title":"GeoData.crs","text":"crs(A::AbstractGeoArray)\n\nGet the coordinate reference system of the array.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.crs-Tuple{Dimension}","page":"GeoData.jl","title":"GeoData.crs","text":"crs(A::AbstractGeoArray)\n\nGet the coordinate reference system of a Dimension.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.disaggregate","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(x, method, scale)\n\nDisagregate array, or all arrays in a stack or series, by some scale. This uses a Array aggregation function like mean, or a [Locus] type to specify a single position to sample from. Return values are GeoArray, GeoStack or GeoSeries depending on the type of x.\n\nmethod is a function such as mean or sum that can combine the   value of multiple cells to generate the disaggregated cell, or a loci   like Start or Center() that species where to sample from in the interval.\nscale is the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.disaggregate!-Tuple{Locus,AbstractDimensionalArray,Any,Any}","page":"GeoData.jl","title":"GeoData.disaggregate!","text":"disaggregate!(dst::AbstractDimensionalArray, src::AbstractDimensionalArray, method, scale)\n\nDisagregate array src to array dst by some scale. This uses an aggregation function like mean or a [Locus] type to specify a position to sample from.\n\nmethod is a function such as mean or sum that can combine the   value of multiple cells to generate the disaggregated cell, or a loci   like Start or Center() that species where to sample from in the interval.\nscale is the aggregation factor, which can be an integer, or a tuple of an Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.disaggregate-Tuple{Any,AbstractDimensionalArray,Any}","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, src::AbstractDimensionalArray, scale)\n\nDisagregate an AbstractDimensionalArray\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.disaggregate-Tuple{Any,AbstractGeoSeries,Any}","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, series::AbstractGeoSeries, scale)\n\nDisagregate an AbstractGeoSeries\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.disaggregate-Tuple{Any,AbstractGeoStack,Any}","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, stack::AbstractGeoStack, scale)\n\nDisagregate an AbstractGeoStack\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.disaggregate-Tuple{Any,IndexMode,Any}","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, dim::IndexMode, scale)\n\nDisagregate an IndexMode\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.disaggregate-Tuple{Any,Span,Any}","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, dim::Span, scale)\n\nDisagregate a Span\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.disaggregate-Tuple{Locus,Dimension,Any}","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, dim::Dimension, scale)\n\nDisagregate a Dimension\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.downsample-Tuple{Int64,Int64}","page":"GeoData.jl","title":"GeoData.downsample","text":"downsample(index::Int, scale::Int)\n\nConvert indicies from the original array to the aggregated array.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.filename-Tuple{GeoData.DiskGeoStack{#s17} where #s17<:NamedTuple,Union{AbstractString, Symbol}}","page":"GeoData.jl","title":"GeoData.filename","text":"filename(s::DiskGeoStack, key)\n\nReturn the filename field of a DiskGeoStack for a given key.\n\nThis will always be a single string. However, in some cases all keys may have the same filename.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.filename-Tuple{GeoData.DiskGeoStack}","page":"GeoData.jl","title":"GeoData.filename","text":"filename(s::DiskGeoStack)\n\nReturn the filename field of a DiskGeoStack. This may be a Vector of String, or a String.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.getsource","page":"GeoData.jl","title":"GeoData.getsource","text":"getsource(s::AbstractGeoStack, [key])\n\nGet the lower lovel child object. This can be an AbstractGeoArray or a lower-level object with GeoData methods defined. Returning the low-level object can be better performance as we do not have to processes everything needed to build a full AbstractGeoArray.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.kwargs-Tuple{AbstractGeoStack}","page":"GeoData.jl","title":"GeoData.kwargs","text":"kwargs(s::AbstractGeoStack)\n\nReturns the keyword arguments that will be passed to the child array constructor.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.missingmask","page":"GeoData.jl","title":"GeoData.missingmask","text":"missingmask(A::AbstractArray, [missingval])\n\nCreate a mask array of missing or true values, from any AbstractArray.  For AbstractGeoArray the default missingval is missingval(A),  for all other AbstractArrays it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a  GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.missingval","page":"GeoData.jl","title":"GeoData.missingval","text":"missingval(x)\n\nReturns the value representing missing data in the dataset\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.replace_missing-Tuple{GeoData.DiskGeoArray,Vararg{Any,N} where N}","page":"GeoData.jl","title":"GeoData.replace_missing","text":"replace_missing(a::AbstractGeoArray, newmissing)\n\nReplace missing values in the array with a new missing value, also updating the missingval field.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.reproject-Tuple{Any,Any,Dimension,Any}","page":"GeoData.jl","title":"GeoData.reproject","text":"reproject uses ArchGDAL.reproject, but implemented for a reprojecting  a single dimension at a time.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.safeapply","page":"GeoData.jl","title":"GeoData.safeapply","text":"safeapply(f::Function, ::AbstractGeoStack, source)\n\nWrapper method to apply a function to data object provided for by a data source.\n\nThis facilitates wrapping the custom file open/close requirements of specific  source libraries to safely deal with disk or api sourced datasets.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.upsample-Tuple{Int64,Int64}","page":"GeoData.jl","title":"GeoData.upsample","text":"upsample(index::Int, scale::Int)\n\nConvert indicies from the aggregated array to the larger original array.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.usercrs","page":"GeoData.jl","title":"GeoData.usercrs","text":"Get the user facing crs projection of a dim or for the Lat/Lon dims of an array.\n\nThis is used to convert Selector values form the user defined projection  to the underlying projection, and to show plot axes in the user projection.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.usercrs-Tuple{AbstractGeoArray}","page":"GeoData.jl","title":"GeoData.usercrs","text":"usercrs(A::AbstractGeoArray)\n\nGet the coordinate reference system of the array.\n\n\n\n\n\n","category":"method"},{"location":"#GeoData.usercrs-Tuple{Dimension}","page":"GeoData.jl","title":"GeoData.usercrs","text":"usercrs(A::AbstractGeoArray)\n\nGet the user input coordinate reference system.\n\n\n\n\n\n","category":"method"}]
}
